var documenterSearchIndex = {"docs":
[{"location":"Dicts/","page":"Dictionaries and names","title":"Dictionaries and names","text":"DocTestSetup = quote\n    using GaPSE\nend","category":"page"},{"location":"Dicts/#IMPLEMENTED*GR*EFFECTS-and-so-on","page":"Dictionaries and names","title":"IMPLEMENTEDGREFFECTS and so on","text":"","category":"section"},{"location":"Dicts/","page":"Dictionaries and names","title":"Dictionaries and names","text":"GaPSE.IMPLEMENTED_GR_EFFECTS\nGaPSE.IMPLEMENTED_Œæs\nGaPSE.DICT_GR_Œæs\nGaPSE.INDEX_GR_EFFECT\nGaPSE.GR_EFFECT_INDEXED","category":"page"},{"location":"SumXiMultipoles/","page":"Sum Xi Multipoles","title":"Sum Xi Multipoles","text":"DocTestSetup = quote\n    using GaPSE\nend","category":"page"},{"location":"SumXiMultipoles/#The-sum-of-all-the-Œæ-multipoles-computation","page":"Sum Xi Multipoles","title":"The sum of all the Œæ multipoles computation","text":"","category":"section"},{"location":"SumXiMultipoles/","page":"Sum Xi Multipoles","title":"Sum Xi Multipoles","text":"GaPSE.sum_Œæ_multipole\nGaPSE.map_sum_Œæ_multipole\nGaPSE.print_map_sum_Œæ_multipole","category":"page"},{"location":"MathUtils/","page":"Mathematical Utilities","title":"Mathematical Utilities","text":"DocTestSetup = quote\n    using GaPSE\nend","category":"page"},{"location":"MathUtils/#Mathematical-Utilities-functions","page":"Mathematical Utilities","title":"Mathematical Utilities functions","text":"","category":"section"},{"location":"MathUtils/","page":"Mathematical Utilities","title":"Mathematical Utilities","text":"GaPSE.warning\n\nGaPSE.derivate_point\nGaPSE.derivate_vector\nGaPSE.spectral_index\nGaPSE.mean_spectral_index\nGaPSE.power_law\nGaPSE.two_power_laws\nGaPSE.power_law_from_data\n\nGaPSE.expanded_left_log\nGaPSE.expanded_right_log\nGaPSE.expanded_IPS\nGaPSE.expanded_Iln\nGaPSE.func_I04_tilde\nGaPSE.expanded_I04_tilde\n\nGaPSE.my_interpolation\nGaPSE.EPLs","category":"page"},{"location":"MathUtils/#GaPSE.derivate_point","page":"Mathematical Utilities","title":"GaPSE.derivate_point","text":" derivate_point(xp, yp, x1, y1, x2, y2)\n\nReturn the derivative in (xp, yp), given the neighboor points (x1,y1) and (x2,y2), with x1 < xp < x2. It is not assumed that x2 - xp = xp - x1.\n\n\n\n\n\n","category":"function"},{"location":"MathUtils/#GaPSE.mean_spectral_index","page":"Mathematical Utilities","title":"GaPSE.mean_spectral_index","text":" mean_spectral_index(xs, ys; N::Integer = 1, con = false)\n\nAssuming that the input ys follow a power law distribution,  return the mean spectral index langle S rangle of them.\n\nThe spectral index S of a generic function f = f(x) is defined as:\n\n     S = fracpartial log f(x)partial log x \n          = fracxf(x) fracpartial f(x)partial x \n\n\n\n\n\n","category":"function"},{"location":"MathUtils/#GaPSE.power_law","page":"Mathematical Utilities","title":"GaPSE.power_law","text":" power_law(x, si, b, a) ::Float64\n\nReturn the following y = f(x) \"spurious\" power-law value:\n\ny = f(x) = a + b  x^s\n\nwhere si is the exponent (s), b the coefficient (b) and a is the added constant (a).\n\n\n\n\n\n","category":"function"},{"location":"MathUtils/#GaPSE.power_law_from_data","page":"Mathematical Utilities","title":"GaPSE.power_law_from_data","text":" power_law_from_data(xs, ys, p0::Vector{Float64},\n      fit_min::Number, fit_max::Number; con = false)\n\n power_law_from_data(xs, ys, p0::Vector{Float64}; con = false) = \n      power_law_from_data(xs, ys, p0, xs[begin], xs[end]; con = con)\n\nReturns the \"spurious\" power-law coefficients s, b and a obtained from the fitting of the data vectors xs and ys inside the limits fit_min and fit_max.\n\nIf con == false, the returned a is always 0.0, because it is considered the \"pure\" power-law fitting function:\n\n     y = f(x) = b  x^s\n\nwhile if con == false it is used the spurious one:\n\n     y = f(x) = a + b  x^s\n\n(and consequently a may be ‚â†0).\n\nThe fitting is performed through the function curve_fit of the  LsqFit Julia package, which is based on the least-squares method.\n\nSee also: power_law\n\n\n\n\n\n","category":"function"},{"location":"MathUtils/#GaPSE.expanded_IPS","page":"Mathematical Utilities","title":"GaPSE.expanded_IPS","text":" expanded_IPS(ks, pks; k_in = 1e-8, k_end = 3e3, con = false)\n\nGiven the ks and pks of a chosen Power Spectrum, returns the same PS with \"longer tails\", i.e. it is prolonged for higher and lower ks than  the input ones.\n\n\n\n\n\n","category":"function"},{"location":"MathUtils/#GaPSE.expanded_Iln","page":"Mathematical Utilities","title":"GaPSE.expanded_Iln","text":" expanded_Iln(PK, l, n; N = 1024, kmin = 1e-4, kmax = 1e3, s0 = 1e-3,\n      fit_left_min = 2.0, fit_left_max = 10.0, p0 = [-1.0, 1.0, 0.0], con = false)\n\n\n\n\n\n","category":"function"},{"location":"MathUtils/#GaPSE.func_I04_tilde","page":"Mathematical Utilities","title":"GaPSE.func_I04_tilde","text":" func_I04_tilde(PK, s, kmin, kmax; kwargs...)\n\nReturn the following integral:\n\ntildeI^4_0 (s) = int_0^infty fracmathrmdq2pi^2 \n     q^2  P(q)  fracj_0(q s) - 1(q s)^4\n\nIt is brute-force calcuated with quadgk.\n\nArguments\n\nPK : function that return the Input Power Spectrum\ns : value of s whre the integral must be evaluated\nkmin, kmax : extremes (min and max) of integration\nkwargs... : keyword argruments that must be passed to quadgk, such as rtol or atol\n\n\n\n\n\n","category":"function"},{"location":"MathUtils/#GaPSE.EPLs","page":"Mathematical Utilities","title":"GaPSE.EPLs","text":" EPLs(\n      l_si::Float64\n      l_b::Float64\n      l_a::Float64\n      left::Float64\n\n      spline::Dierckx.Spline1D\n\n      r_si::Float64\n      r_b::Float64\n      r_a::Float64\n      right::Float64\n )\n\nContains all the information useful in order to return the value of a spline inside the interval left ‚â§ x ‚â§ right and the associated power laws for the edges (with the \"left\" coefficients l_si, l_b and l_a for x < left and the \"right\" ones r_si, r_b and  r_a for x > right)\n\nArguments\n\nl_si, l_b, l_a :: Float64 : coefficient for the spurious power-law  y = f(x) = a + b  x^s for the LEFT edge; when an input value x < left is given, the returned one is obtained from power_law with this coefficients ( where, of course, l_si is the exponent, l_b the coefficient and l_a the  spurious adding constant). \nleft::Float64 : the break between the left power-law (for x <left) and the  spline (for x ‚â• left); its value is the xs[begin] one.\nspline::Dierckx.Spline1D : spline that interpolates between the real values of the  integral calculated inside the range left ‚â§ x ‚â§ right\nright::Float64 : the break between the right power-law (for x ‚â• left) and the  spline (for x ‚â§ right); its value is the xs[end] one.\nr_si, r_b, r_a :: Float64 : coefficient for the spurious power-law  y = f(x) = a + b  x^s for the RIGHT edge; when an input value x > right is given, the returned one is obtained from power_law with this coefficients ( where, of course, r_si is the exponent, r_bthe coefficient andr_athe  spurious adding constant).  NOTE: for numerical issues, the \"pure\" power-lawy = f(x) = b + x^s` should be used. \n\nConstructors\n\n`EPLs(xs, ys, p0left::Vector{T1}, p0right::Vector{T2};       Nleft::Integer = 15, Nright::Integer = 15) where {T1<:Real, T2 <:Real}\n\nxs and ys: the input vector of values. \nN_left::Integer = 15 : number of points to be used from the left edge for the left power law-fitting. It shouldn't be too low (< 4) or too high (>100).\nN_right::Integer = 15 : number of points to be used from the right edge for the right power law-fitting. It shouldn't be too low (< 4) or too high (>100).\np0_left::Vector{T1} where T1 <:Real : vector with the initial values for the left power-law fitting; its length must    be 2 (if you want to fit with a pure power-law y = f(x) = b * x^s, so only l_si and l_b     are matter of concern) or 3 (if you want to fit with a spurious power-law y = f(x) = a + b * x^s,    so you are also interested in l_a); in the first case, the considered l_a will be 0.0.    Example: \np0_right::Vector{T1} where T1 <:Real : vector with the initial values for the right power-law fitting; its length must    be 2 (if you want to fit with a pure power-law y = f(x) = b * x^s, so only r_si and r_b     are matter of concern) or 3 (if you want to fit with a spurious power-law y = f(x) = a + b * x^s,    so you are also interested in r_a); in the first case, the considered r_a will be 0.0.    It is recommended to \n\nAll the power-law fitting (both \"pure\" and spurious) are made through the  local function power_law_from_data.\n\nExamples\n\njulia> xs = 10 .^ range(0, 2, length=100);\n\njulia> ys = [1.34e2 * x ^ 2.43 for x in xs];\n\njulia> A = EPLs(xs, ys, [1.0, 1.0], [1.0, 1.0]; N_left = 10, N_right = 10)\n\nSee also: power_law_from_data\n\n\n\n\n\n","category":"type"},{"location":"AutoCorrelations/","page":"Auto Correlations","title":"Auto Correlations","text":"DocTestSetup = quote\n    using GaPSE\nend","category":"page"},{"location":"AutoCorrelations/#Auto-Correlation-functions","page":"Auto Correlations","title":"Auto-Correlation functions","text":"","category":"section"},{"location":"AutoCorrelations/","page":"Auto Correlations","title":"Auto Correlations","text":"GaPSE.Œæ_Doppler\nGaPSE.Œæ_Lensing\nGaPSE.Œæ_LocalGP\nGaPSE.Œæ_IntegratedGP\nGaPSE.integrand_Œæ_Lensing\nGaPSE.integrand_Œæ_IntegratedGP","category":"page"},{"location":"IPSTools/","page":"Input Power Spectrum Tools","title":"Input Power Spectrum Tools","text":"DocTestSetup = quote\n    using GaPSE\nend","category":"page"},{"location":"IPSTools/#Tool-functions","page":"Input Power Spectrum Tools","title":"Tool functions","text":"","category":"section"},{"location":"IPSTools/","page":"Input Power Spectrum Tools","title":"Input Power Spectrum Tools","text":"GaPSE.InputPS\nGaPSE.IntegralIPS\nGaPSE.IPSTools","category":"page"},{"location":"IPSTools/#GaPSE.InputPS","page":"Input Power Spectrum Tools","title":"GaPSE.InputPS","text":" InputPS(\n      l_si::Float64\n      l_b::Float64\n      l_a::Float64\n      left::Float64\n\n      spline::Dierckx.Spline1D\n      \n      r_si::Float64\n      r_b::Float64\n      r_a::Float64\n      right::Float64)\n\nStore the Input Power Spectrum.\n\nArguments\n\nl_si, l_b, l_a :: Float64 : coefficient for the spurious power-law  y = f(x) = a + b  x^s for the LEFT edge; when an input value x < left is given, the returned one is obtained from power_law with this coefficients ( where, of course, l_si is the exponent, l_b the coefficient and l_a the  spurious adding constant). \nleft::Float64 : the break between the left power-law (for x <left) and the  spline (for x ‚â• left); its value is the fit_min of the used constructor.\nspline::Dierckx.Spline1D : spline that interpolates between the real values of the  power spectrum inside the range left ‚â§ x ‚â§ right\nright::Float64 : the break between the right power-law (for x > left) and the  spline (for x ‚â§ right); its value is the fit_max of the used constructor.\nr_si, r_b, r_a :: Float64 : coefficient for the spurious power-law  y = f(x) = a + b  x^s for the RIGHT edge; when an input value x > right is given, the returned one is obtained from power_law with this coefficients ( where, of course, r_si is the exponent, r_bthe coefficient andrathe  spurious adding constant).  NOTE: for numerical issues, only the \"pure\" power-lawy = f(x) = b + x^scan be used.  In other words, it always setra = 0.0`.\n\nConstructors\n\nInputPS(file::String; fit_left_min = 1e-6, fit_left_max = 3e-6,    fit_right_min = 1e1, fit_right_max = 2e1) : read the IPS from the given input file; it can contain comments (defined with a  starting # on each line), but the file structure must be space-separated in two colums (former for k values, latter for P ones).\nfit_left_min = 1e-6, fit_left_max = 3e-6 : the limits (min and max) where the PS must be fitted with a power law, for small wavenumbers. \nfit_right_min = 1e1, fit_right_max = 2e1 : the limits (min and max) where the PS must be fitted with a power law, for high wavenumbers. \n\nInputPS(ks::AbstractVector{T1}, pks::AbstractVector{T2}; fit_left_min = 1e-6, fit_left_max = 3e-6,    fit_right_min = 1e1, fit_right_max = 2e1)\nks::AbstractVector{T1}, pks::AbstractVector{T2} : self-explanatory ks and pks array-like values.\nfit_left_min = 1e-6, fit_left_max = 3e-6 : the limits (min and max) where the PS must be fitted with a power law, for small wavenumbers. \nfit_right_min = 1e1, fit_right_max = 2e1 : the limits (min and max) where the PS must be fitted with a power law, for high wavenumbers. \n\nAll the power-law fitting (both \"pure\" and spurious) are made through the  local function power_law_from_data.\n\nSee also: power_law_from_data\n\n\n\n\n\n","category":"type"},{"location":"IPSTools/#GaPSE.IntegralIPS","page":"Input Power Spectrum Tools","title":"GaPSE.IntegralIPS","text":" IntegralIPS(\n      l_si::Float64\n      l_b::Float64\n      l_a::Float64\n      left::Float64\n\n      spline::Dierckx.Spline1D\n\n      r_si::Float64\n      r_b::Float64\n      r_a::Float64\n      right::Float64\n )\n\nContains all the information useful in order to return the value of an integral obtained from the Input Power Spectrum.\n\nArguments\n\nl_si, l_b, l_a :: Float64 : coefficient for the spurious power-law  y = f(x) = a + b  x^s for the LEFT edge; when an input value x < left is given, the returned one is obtained from power_law with this coefficients ( where, of course, l_si is the exponent, l_b the coefficient and l_a the  spurious adding constant). \nleft::Float64 : the break between the left power-law (for x <left) and the  spline (for x ‚â• left); its value is the fit_min of the used constructor.\nspline::Dierckx.Spline1D : spline that interpolates between the real values of the  integral calculated inside the range left ‚â§ x ‚â§ right\nright::Float64 : the break between the right power-law (for x > left) and the  spline (for x ‚â§ right); its value is the fit_max of the used constructor.\nr_si, r_b, r_a :: Float64 : coefficient for the spurious power-law  y = f(x) = a + b  x^s for the RIGHT edge; when an input value x > right is given, the returned one is obtained from power_law with this coefficients ( where, of course, r_si is the exponent, r_bthe coefficient andrathe  spurious adding constant).  NOTE: for numerical issues, only the \"pure\" power-lawy = f(x) = b + x^scan be used.  In other words, it always setra = 0.0`.\n\nConstructors\n\nThere are two type of integrals we are interested in, and so two constructors are here provided:\n\nIntegralIPS(ips, l, n; N::Integer = 1024, kmin = 1e-4, kmax = 1e3, s0 = 1e-3,    fit_left_min = 2.0, fit_left_max = 10.0, p0_left = nothing, con = false,    fit_right_min = nothing, fit_right_max = nothing, p0_right = nothing) This is the one used for the \"classical\" I_ell_n integrals:\nI_ell^n(s) = int_0^infty fracmathrmd q2 pi^2 q^2  P(q) \n   fracj_ell(qs)(qs)^n\nwhere, for a generic Iab name, ell is the FIRST number (a) and  n the second (b). The integral obtained with this constructor is calculated through xicalc, and expanded with power-laws at the edges.\nips: the function/spline that gives the Input Power Spectrum\nl and n: self-explanatory degree of the integral, with the convenction above mentioned\nkmin = 1e-4, kmax = 1e3, s0 = 1e-3 : values to be passed to xicalc for the integration\nfit_left_min = 2.0, fit_left_max = 10.0, : the limits (min and max) where the integral I_ell^n must be fitted with a power law, for small distances. This operation is necessary, because xicalc, in this context, gives wrong results for too small input distance s; nevertheless, all these I_ell^n integrals have fixed power-law trends for s rightarrow 0, so this approach gives good results.\np0_left = nothing : vector with the initial values for the left power-law fitting; its length must be 2 (if you want to fit with a pure power-law y = f(x) = b * x^s, so only l_si and l_b  are matter of concern) or 3 (if you want to fit with a spurious power-law y = f(x) = a + b * x^s, so you are also interested in l_a), depending on the value of con; if nothing, it will be automatically set p0 = [-1.0, 1.0, 0.0] for con==true and p0 = [-1.0, 1.0] for con==false.\ncon::Bool = false : do you want that the fit of all the I_ell^n for the LEFT edge is not a simple power-law y = f(x) = b  x^s, but also consider a constant a, such that y = f(x) = a + b  x^s? For the LEFT side, there is not a lot of difference empirically.  For the RIGHT side, there is not such an option due to numerical problems (it's like  is always set con==false).\nfit_right_min = nothing, fit_right_max = nothing : the limits (min and max) where the integral I_ell^n must be fitted with a power law, for high distances.  These I_ell^n integrals have fixed power-law trends for s rightarrow infty, so this approach gives good results. If nothing, the last 15 points returned from xicalc are used for this fitting. NOTE: for numerical issues, only the \"pure\" power-law y = f(x) = b + x^s can be used. \np0_right = nothing : vector with the initial values for the left power-law fitting; its length must be 2 (to fit with a pure power-law y = f(x) = b * x^s, so only r_si and r_b  are matter of concern); if nothing, it will be automatically set p0 = [-4.0, 1.0, 0.0].\n\nIntegralIPS(ips, func::Function; N::Integer = 1024, kmin = 1e-4, kmax = 1e3,    fit_left_min = 0.1, fit_left_max = 1.0, p0_left = nothing, con = false,    fit_right_min = nothing, fit_right_max = nothing, p0_right = nothing,    kwargs...) This is the one used for the \"strange\" tildeI integrals, such as:\ntildeI^4_0 (s) = int fracmathrmdq2pi^2  q^2  \n   P(q)   fracj_0(qs) - 1(qs)^4 \nThe integral obtained with this constructor is calculated through the input function func, and expanded with power-laws at the edges. For \\tilde{I}^4_0, the function is func_I04_tilde.  \nips: the function/spline that gives the Input Power Spectrum\nfunc: function that return the value of this specific integral in a given value\nkmin = 1e-4, kmax = 1e3, s0 = 1e-3 : values to be passed to func as extremes of integration\nfit_left_min = 0.1, fit_left_max = 1.0, : the limits (min and max) where the integral tildeI must be fitted with a power law, for small distances. This operation is necessary, because xicalc, in this context, gives wrong results for too small input distance s; nevertheless, all this tildeI integral have fixed power-law trends for s rightarrow 0, so this approach gives good results.\np0_left = nothing : vector with the initial values for the left power-law fitting; its length must be 2 (if you want to fit with a pure power-law y = f(x) = b * x^s, so only l_si and l_b  are matter of concern) or 3 (if you want to fit with a spurious power-law y = f(x) = a + b * x^s, so you are also interested in l_a), depending on the value of con; if nothing, it will be automatically set p0 = [-2.0, -1.0, 0.0] for con==true and p0 = [-2.0, -1.0] for con==false.\ncon::Bool = false : do you want that the fit of all the I_ell^n for the LEFT edge is not a simple power-law y = f(x) = b  x^s, but also consider a constant a, such that y = f(x) = a + b  x^s? For the LEFT side, there is not a lot of difference empirically.  For the RIGHT side, there is not such an option due to numerical problems (it's like  is always set con==false).\nfit_right_min = nothing, fit_right_max = nothing : the limits (min and max) where the integral I_ell^n must be fitted with a power law, for high distances.  These I_ell^n integrals have fixed power-law trends for s rightarrow infty, so this approach gives good results. If nothing, the last 15 points returned from xicalc are used for this fitting. NOTE: for numerical issues, only the \"pure\" power-law y = f(x) = b + x^s can be used. \np0_right = nothing : vector with the initial values for the left power-law fitting; its length must be 2 (to fit with a pure power-law y = f(x) = b * x^s, so only r_si and r_b  are matter of concern); if nothing, it will be automatically set p0 = [-4.0, -1.0].\n\nAll the power-law fitting (both \"pure\" and spurious) are made through the  local function power_law_from_data.\n\nSee also: power_law_from_data, func_I04_tilde\n\n\n\n\n\n","category":"type"},{"location":"IPSTools/#GaPSE.IPSTools","page":"Input Power Spectrum Tools","title":"GaPSE.IPSTools","text":" IPSTools(\n      I00::IntegralIPS\n      I20::IntegralIPS\n      I40::IntegralIPS\n      I02::IntegralIPS\n      I22::IntegralIPS\n      I31::IntegralIPS\n      I13::IntegralIPS\n      I11::IntegralIPS\n\n      I04_tilde::IntegralIPS\n\n      œÉ_0::Float64\n      œÉ_1::Float64\n      œÉ_2::Float64\n      œÉ_3::Float64\n\n      fit_min::Union{Float64,Nothing}\n      fit_max::Union{Float64,Nothing}\n      k_min::Float64\n      k_max::Float64\n      s_0::Float64\n      )\n\nStruct that contains all the useful functions and values obtained from the  Input Power Spectrum.\n\nArguments\n\nI00, I20, I40, I02, I22, I31, I13, I11 ::IntegralIPS: they return the value of the corresponding integral:\nI_ell^n(s) = int_0^infty fracmathrmd q2 pi^2 q^2  P(q) \n   fracj_ell(qs)(qs)^n\nwhere, for a generic Iab name, ell is the FIRST number (a) and  n the second (b). These integrals are performed through xicalc, with kmin, kmax, s0 = 1e-5, 1e3, 1e-3; at the edges they are fitted with power laws (for s < fit_min and  s > max_s_returned_from_xi_calc).\nI04_tilde::IntegralIPS: it returns the value of the integral:\ntildeI^4_0 (s) = int fracmathrmdq2pi^2  q^2  \n   P(q)   fracj_0(qs) - 1(qs)^4 \nThis integral is calculated brute-force with quadgk, and fitted with power-laws at the edges (for s < 0.1 and s > 1e4).\nœÉ_0, œÉ_1, œÉ_2, œÉ_3 :: Float64: these are the results of the following integral:\nsigma_i = int_k_mathrmmin^k_mathrmmax fracmathrmd q2 pi^2  q^2-i  P(q)\nfit_min, fit_max :: Float64: the limits (min and max) where the integral I_ell^n must be fitted with a power law, for small distances. This operation is necessary, because xicalc, in this context, gives wrong results for too small input distance s; nevertheless, all these I_ell^n integrals have fixed power-law trends for s rightarrow 0, so this approach gives good results.\nk_min k_max::Float64 : because some of the sigma_i integrals from q = 0 to q = +infty diverge, it is common practice to cut the integrals at the edges, so they are calculated from q = k_mathrmmin to q = k_mathrmmax\n\nConstructors\n\nIPSTools(ips::InputPS; N::Integer = 1024,      fit_min::Float64 = 0.05, fit_max::Float64 = 0.5,      k_min::Float64 = 1e-6, k_max::Float64 = 10.0      con::Bool = false      )\n\nips::InputPS : the Input Power Spectrum to be used in all the calculations.\nN::Integer = 1024 : number of points to be used in the xicalc function\nk_min::Float64 = 1e-6, k_max::Float64 = 10.0 : integrations extremes of  the sigma_is\ncon::Bool = false : do you want that the fit of all the I_ell^n for the LEFT edge is not a simple power-law y = f(x) = b  x^s, but also consider a constant a, such that y = f(x) = a + b  x^s? For the LEFT side, there is not a lot of difference empirically.  For the RIGHT side, there is not such an option due to numerical problems (it's like  is always set con==false).\n\nSee also: IntegralIPS, InputPS\n\n\n\n\n\n","category":"type"},{"location":"WindowF/","page":"The F window function","title":"The F window function","text":"DocTestSetup = quote\n    using GaPSE\nend","category":"page"},{"location":"WindowF/#The-F-window-function","page":"The F window function","title":"The F window function","text":"","category":"section"},{"location":"WindowF/","page":"The F window function","title":"The F window function","text":"GaPSE.F\nGaPSE.F_map\nGaPSE.integrand_F\nGaPSE.WindowF\nGaPSE.spline_F","category":"page"},{"location":"WindowF/#GaPSE.integrand_F","page":"The F window function","title":"GaPSE.integrand_F","text":"integrand_F(Œ∏_1, Œ∏, x, Œº, Œ∏_max; tolerance=1e-8) :: Float64\n\nReturn the integrand of the function F(xmu theta_mathrmmax), i.e the  function f(xmu theta theta_1 theta_mathrmmax):\n\nbeginsplit\nf(xmu theta theta_1 theta_mathrmmax) = \n     Thetaleft( frac\n        x cos theta + cos theta_1sqrtx^1+2+2xmu - \n        cos(theta_mathrmmax) \n        right) \n     times  Theta(mu-cos(theta+theta_1))   times \n     quad Theta(cos(theta - theta_1)-mu)  times \n    frac4pi sinthetasintheta_1\n        sqrt(sinthetasintheta_1)^2-(costhetacostheta_1-mu)^2\nendsplit\n\nbeginequation\nF(xmu theta_mathrmmax) = int_0^theta_mathrmmax \n        mathrmdtheta_1 int_0^pi mathrmd theta \n         f(xmu theta theta_1 theta_mathrmmax)\nendequation\n\ntolerance is a parameter needed in case of small negative denominator: the Heaviside theta function mathematically prevent that  mathrmden=(sinthetasintheta_1)^2-(costhetacostheta_1-mu)^2 becomes negative, but computationally might happen that mathrmden results as a very small negative number (for instance -1.2368946523-18); in this case tolerance solve the problem, returning 0 if 0-mathrmden mathrmtolerance\n\nSee also: F, map_F\n\n\n\n\n\n","category":"function"},{"location":"WindowF/#GaPSE.WindowF","page":"The F window function","title":"GaPSE.WindowF","text":"WindowF(\n    xs::Vector{Float64}\n    Œºs::Vector{Float64}\n    Fs::Matrix{Float64}\n    )\n\nStruct containing xs, Œºs and Fs values of the window function F(x Œº). xs and Œºs are 1D vectors containing each value only once, while  Fs values are contained in a matrix of size (length(xs), length(Œºs)), so:\n\nalong a fixed column the changing value is x\nalong a fixed row the changing value is Œº\n\nConstructors\n\nWindowF(file::String) : read the F map from the file file. Such a file might be produced by print_map_F, check its docstring. \n\nIt does not matter if the pattern is\n\n# xs      Œºs      Fs\n0.0       -1.0       ...\n0.0       -0.9       ...\n0.0       -0.8       ...\n...       ...      ...\n\nor \n\n# xs      Œºs      Fs\n0.0       -1.0       ...\n0.1       -1.0       ...\n0.2       -1.0       ...\n...       ...      ...\n\nbecause the constructor will recognise it. What does matter is the columns order: xs first, then Œºs and finally Fs.\n\nSee also: print_map_F, F_trap, spline_F\n\n\n\n\n\n","category":"type"},{"location":"WindowF/#GaPSE.spline_F","page":"The F window function","title":"GaPSE.spline_F","text":" spline_F(x, Œº, str::WindowF)) ::Float64\n\nReturn the 2-dim spline value of F in the given (x,Œº), where F is defined in the input WindowF. The spline is obtained through the interpolate function of the  GridInterpolations Julia package.\n\nSee also: WindowF\n\n\n\n\n\n","category":"function"},{"location":"Cosmology/","page":"Cosmology Struct","title":"Cosmology Struct","text":"DocTestSetup = quote\n    using GaPSE\nend","category":"page"},{"location":"Cosmology/#Cosmology-struct","page":"Cosmology Struct","title":"Cosmology struct","text":"","category":"section"},{"location":"Cosmology/","page":"Cosmology Struct","title":"Cosmology Struct","text":"GaPSE.func_‚Ñõ\nGaPSE.Cosmology\nGaPSE.Point  ","category":"page"},{"location":"Cosmology/#GaPSE.Cosmology","page":"Cosmology Struct","title":"GaPSE.Cosmology","text":" Cosmology(\n      IPS::InputPS\n      params::CosmoParams\n      tools::IPSTools\n      windowF::WindowF\n\n      z_of_s::Dierckx.Spline1D\n      D_of_s::Dierckx.Spline1D\n      f_of_s::Dierckx.Spline1D\n      ‚Ñã_of_s::Dierckx.Spline1D\n      ‚Ñã_p_of_s::Dierckx.Spline1D\n      ‚Ñõ_LD_of_s::Dierckx.Spline1D\n      ‚Ñõ_GNC_of_s::Dierckx.Spline1D\n\n      s_of_z::Dierckx.Spline1D\n\n      z_eff::Float64\n      s_min::Float64\n      s_max::Float64\n      s_eff::Float64\n\n      volume::Float64\n\n      file_data::String\n      file_ips::String\n      file_windowF::String\n      )\n\nStruct that contains all the information that may be used for the  Correlation Function computations.\n\nArguments\n\nIPS::InputPS : the matter Input Power Spectrum of the Universe we are focusiong on.\nparams::CosmoParams : options and parameters decided for this Cosmology.\ntools::IPSTools : all the functions and integrals depending on the Input PS.\nwindowF::WindowF : the window function F, defined as:\n   beginsplit\n   F(xmu theta_mathrmmax) =  4pi \n   int_0^theta_mathrmmax mathrmdtheta_1 int_0^pi mathrmd theta  \n    Thetaleft(frac\n        x cos theta + cos theta_1sqrtx^1+2+2xmu - \n        cos(theta_mathrmmax) \n        right) \n    Theta(mu-cos(theta+theta_1)) \n   Theta(cos(theta - theta_1)-mu) \n   fracsinthetasintheta_1\n        sqrt(sinthetasintheta_1)^2-(costhetacostheta_1-mu)^2\n   endsplit\nz_of_s, D_of_s, f_of_s, ‚Ñã_of_s, ‚Ñã_p_of_s, ‚Ñõ_LD_of_s, ‚Ñõ_GNC_of_s ::Dierckx.Spline1D : splines obtained from the data stored by BackgroundData applied to the input background  data file. Given an input comoving distance s, they return the corresponding value of, respectivelly:\nthe redshift z;\nthe growth factor D;\nthe growth rate f;\nthe comoving Hubble parameter ‚Ñã;\nthe derivative of the comoving Hubble parameter wrt the comoving time ‚Ñã_p; \n‚Ñõ_LD, obtained from func_‚Ñõ_LD anddefined as:\n   scrR_mathrmLD = 1 - frac1scrH  s\n‚Ñõ_GNC, obtained from func_‚Ñõ_GNC and defined as:\n   scrR_mathrmGNC = 5 s_b + frac2 - 5 s_bscrH  s +  \n   fracdotscrHscrH^2 - itf_mathrmevo\ns_of_z ::Dierckx.Spline1D : spline that returns the value of the comoving distance s corresponding to an input redshift z. Also this spline is obtained from the data stored by  BackgroundData applied to the input background data file.\nz_eff::Float64 : effective redshift of this survey; its value is obtained through the function func_z_eff, with inputs the s_min, s_max and z_of_s here stored.\ns_min::Float64 and s_max::Float64 : the minimum and maximum comoving distances of the survey considered; they are the corresponding comoving distance to the chosen minimum and maximum redshifts z_min and z_max, stored in the input CosmoParams.\ns_eff::Float64 : the corresponding comoving distance to the computed effective  redshifts z_eff.\nvolume::Float64 : volume of this survey. It is computed applying the function V_survey with inputs s_min, s_max here stored and the Œ∏_max in the input CosmoParams.\nfile_data, file_ips, file_windowF::String : the file names used for this Cosmology.\n\nConstructors\n\nCosmology(      params::CosmoParams,      file_data::String,      file_ips::String,      file_windowF::String,      file_Is::Union{String,Nothing} = nothing;      names_bg = NAMES_BACKGROUND)\n\nparams::CosmoParams : parameters to be used for this Cosmology. See the docstring of CosmoParams for more information on the possible inputs.\nfile_data::String : file containing all the background data; it is expected that such file is a background output of the CLASS program (link: https://github.com/lesgourg/class_public). It is managed through BackgroundData.\nfile_ips::String : file containing the Input Power Spectrum; it is expected that such file is a power spectrum output of the CLASS program (link: https://github.com/lesgourg/class_public). It is managed through InputPS.\nfile_windowF::String : file containing a map of the window function F. This file is managed through WindowF, and can be produced with F_map; see their docstrings for more information.\nfile_Is::Union{String,Nothing} = nothing : if you want to given in input manually all the I_ell^n integrals, you can set as input the file containing them. It is expected that they are ordered in colums with the following order: s  I00  I20  I40  I02  I22  I31  I11  I13  I04_tilde. If nothing is passed (recommended), they are manually calculated from the Input Power Spectrum.\nnames = NAMES_BACKGROUND : the column names of the file_data. If the colum order change from the default one NAMES_BACKGROUND, you must set as input the vector of string with the correct one, with the SAME names. They are, with the default order:\n[\"z\", \"proper time [Gyr]\", \"conf. time [Mpc]\", \"H [1/Mpc]\", \"comov. dist.\", \"ang.diam.dist.\", \"lum. dist.\", \"comov.snd.hrz.\", \"(.)rhog\", \"(.)rhob\", \"(.)rhocdm\", \"(.)rholambda\", \"(.)rhour\", \"(.)rhocrit\", \"gr.fac. D\", \"gr.fac. f\"]  \n\nSee also:  InputPS, CosmoParams, IPSTools, BackgroundData, WindowF, F_map, func_z_eff, V_survey, func_‚Ñõ_LD, func_‚Ñõ_GNC, \n\n\n\n\n\n","category":"type"},{"location":"Cosmology/#GaPSE.Point","page":"Cosmology Struct","title":"GaPSE.Point","text":" Point(\n      z::Float64\n      #conftime::Float64\n      comdist::Float64\n      #angdist::Float64\n      #lumdist::Float64\n      D::Float64\n      f::Float64\n      ‚Ñã::Float64\n      ‚Ñã_p::Float64\n      ‚Ñõ_LD::Float64\n      ‚Ñõ_GNC::Float64\n      a::Float64)\n\nA point in the Universe, placed at redshift z from us. It contains all the relevant cosmological information at that redshift.\n\nConstructors\n\nPoint(s, cosmo::Cosmology) : given a comoving distance s, extrapolate all  the data from the given input Cosmology.\n\nSee also: Cosmology\n\n\n\n\n\n","category":"type"},{"location":"CosmoParams/","page":"Cosmology Parameters","title":"Cosmology Parameters","text":"DocTestSetup = quote\n    using GaPSE\nend","category":"page"},{"location":"CosmoParams/#The-Cosmology-Parameters","page":"Cosmology Parameters","title":"The Cosmology Parameters","text":"","category":"section"},{"location":"CosmoParams/","page":"Cosmology Parameters","title":"Cosmology Parameters","text":"GaPSE.DEFAULT_IPS_OPTS\nGaPSE.DEFAULT_IPSTOOLS_OPTS\nGaPSE.CosmoParams","category":"page"},{"location":"CosmoParams/#GaPSE.DEFAULT_IPS_OPTS","page":"Cosmology Parameters","title":"GaPSE.DEFAULT_IPS_OPTS","text":" const DEFAULT_IPS_OPTS = Dict(\n      :fit_left_min => 1e-6::Float64, \n      :fit_left_max => 3e-6::Float64,\n      :fit_right_min => 1e1::Float64, \n      :fit_right_max => 2e1::Float64,\n      )\n\nThe default values to be stored in CosmoParams concerning the  Input Power Spectrum. In the Cosmology that will have such CosmoParams as input, they will be used in its InputPS.\n\nSee also: CosmoParams, Cosmology, InputPS\n\n\n\n\n\n","category":"constant"},{"location":"CosmoParams/#GaPSE.DEFAULT_IPSTOOLS_OPTS","page":"Cosmology Parameters","title":"GaPSE.DEFAULT_IPSTOOLS_OPTS","text":" const DEFAULT_IPSTOOLS_OPTS = Dict(\n      :N => 1024::Integer,\n      :fit_min => 0.05::Float64,\n      :fit_max => 0.5::Float64,\n      :con => true::Bool,\n      :k_min => 1e-6::Float64,\n      :k_max => 10.0::Float64,\n )\n\nThe default values to be stored in CosmoParams concerning the  Input Power Spectrum Tools. In the Cosmology that will have such CosmoParams as input, they will be used in its IPSTools.\n\nSee also: CosmoParams, Cosmology, IPSTools\n\n\n\n\n\n","category":"constant"},{"location":"CosmoParams/#GaPSE.CosmoParams","page":"Cosmology Parameters","title":"GaPSE.CosmoParams","text":" CosmoParams(\n      z_min::Float64\n      z_max::Float64\n      Œ∏_max::Float64\n\n      Œ©_b::Float64\n      Œ©_cdm::Float64\n      Œ©_M0::Float64\n      h_0::Float64\n\n      b::Float64\n      s_b::Float64\n      ùëì_evo::Float64\n\n      s_lim::Float64\n\n      IPS::Dict{Symbol,T1} where {T1}\n      IPSTools::Dict{Symbol,T2} where {T2}\n      WFI::Dict{Symbol,T3} where {T3}\n )\n\nStruct that contains all the parameters and options that are  matter of concerns for the Cosmology we are interested in.\n\nArguments\n\nz_min::Float64 and z_max::Float64 : the minimum and maximum redshifts of the survey we want to study.\nŒ∏_max::Float64 : Angular maximum value of the survey. It is implicitly assumed an azimutal simmetry of the survey.\nŒ©_b::Float64, Œ©_cdm::Float64 and Œ©_M0::Float64 : barionic, cold-dark-matter and total matter density parameters.\nh_0::Float64 : today's Hubble adimensional parameter (H_0 = h_0 * 100 km/(s * Mpc)).\nb::Float64 : galaxy bias.\ns_b::Float64 : magnification bias, i.e. the slope of the luminosity function at the luminosity threshold.\nùëì_evo::Float64 : evolution bias.\ns_lim::Float64 : the lower-bound value for the function func_‚Ñõ_LD; it is necessary, because ‚Ñõ_LD blows up for s rightarrow 0^+. Consequently, if the func_‚Ñõ_LD input value is  0 ‚â§ s < s_lim, the returned value is always func_‚Ñõ_LD(s_lim).\nIPS::Dict{Symbol,T1} where {T1} : dictionary concerning all the options that should be  passed to InputPS in the contruction of a Cosmology. The allowed keys, with their default values, are stored in  DEFAULT_IPS_OPTS, and are the following:\n:fit_left_min => 1e-6 and :fit_left_max => 3e-6 : the limits (min and max) where the PS must be fitted with a (pure) power law, for small wavenumbers. \n:fit_right_min => 1e1 and :fit_right_max => 2e1 : the limits (min and max) where the PS must be fitted with a (pure) power law, for high wavenumbers. \nIPSTools::Dict{Symbol,T2} where {T2} : dictionary concerning all the options that should be  passed to IPSTools in the contruction of a Cosmology. The allowed keys, with their default values, are stored in  DEFAULT_IPSTOOLS_OPTS, and are the following:\n:fit_min => 0.05 and :fit_max => 0.5 : the limits (min and max)  where the integral I_ell^n in Cosmology must be fitted with a power law,  for small distances. This operation is necessary, because xicalc, in this context,  gives wrong results for too small input distance s; nevertheless, all these I_ell^n  integrals have fixed power-law trends for s rightarrow 0, so this approach gives good results.\n:N => 1024 : number of points to be used in the Sperical Bessel Fourier Transform made by xicalc in IPSTools.\n:k_min => 1e-6 and :k_max => 10.0 : extremes of integration for the œÉ_i integrals in IPSTools.\n:con => true : do you want that the fit of all the I_ell^n in IPSTools for  the LEFT edge is not a simple power-law y = f(x) = b  x^s, but also consider  a constant a, such that y = f(x) = a + b  x^s?\n\nConstructors\n\nCosmoParams(z_min, z_max, Œ∏_max;           Œ©_b = 0.0489, Œ©_cdm = 0.251020, h_0 = 0.70, s_lim = 1e-2,           IPS_opts::Dict = Dict{Symbol,Any}(),           IPSTools_opts::Dict = Dict{Symbol,Any}()      ) The associations are trivials, with Œ©_M0 = Œ©_cdm + Œ©_b. For the two dictionary, you may pass only the key and the value you are interested in, and all the other default ones will be considered. For example, if you set:\n\nIPSTools_opts = Dict(:N => 150, :con => false, :k_max => 30.0)\n\nthen the dictionary with all the options that will be passed to IPSTools will be:\n\nIPSTools = merge(DEFAULT_IPSTOOLS_OPTS, IPSTools_opts) =       :fit_min => 0.05,   # default      :fit_max => 0.5,    # default      :N => 150,          # CHANGED VALUE      :con => false,      # CHANGED VALUE      :k_min => 1e-6,     # default      :k_max => 30.0,     # CHANGED VALUE )\n\nand similar for IPS_opts.\n\nSee also: Cosmology, IPSTools,  InputPS,  func_‚Ñõ_LD, DEFAULT_IPSTOOLS_OPTS, DEFAULT_IPS_OPTS, DEFAULT_WFI_OPTS, check_compatible_dicts\n\n\n\n\n\n","category":"type"},{"location":"XiMultipoles/","page":"Xi Multipoles","title":"Xi Multipoles","text":"DocTestSetup = quote\n    using GaPSE\nend","category":"page"},{"location":"XiMultipoles/#The-Œæ-multipoles-computation","page":"Xi Multipoles","title":"The Œæ multipoles computation","text":"","category":"section"},{"location":"XiMultipoles/","page":"Xi Multipoles","title":"Xi Multipoles","text":"GaPSE.integrand_Œæ_multipole\nGaPSE.Œæ_multipole\nGaPSE.map_Œæ_multipole\nGaPSE.print_map_Œæ_multipole","category":"page"},{"location":"CrossCorrelations/","page":"CrossCorrelations","title":"CrossCorrelations","text":"DocTestSetup = quote\n    using GaPSE\nend","category":"page"},{"location":"CrossCorrelations/#Cross-Correlation-functions","page":"CrossCorrelations","title":"Cross-Correlation functions","text":"","category":"section"},{"location":"CrossCorrelations/","page":"CrossCorrelations","title":"CrossCorrelations","text":"GaPSE.Œæ_Lensing_Doppler\nGaPSE.Œæ_Doppler_Lensing\nGaPSE.Œæ_Doppler_LocalGP\nGaPSE.Œæ_LocalGP_Doppler\nGaPSE.Œæ_Doppler_IntegratedGP\nGaPSE.Œæ_IntegratedGP_Doppler\nGaPSE.Œæ_Lensing_LocalGP\nGaPSE.Œæ_LocalGP_Lensing,\nGaPSE.Œæ_Lensing_IntegratedGP\nGaPSE.Œæ_IntegratedGP_Lensing\nGaPSE.Œæ_LocalGP_IntegratedGP\nGaPSE.Œæ_IntegratedGP_LocalGP","category":"page"},{"location":"BackgroundData/","page":"Background Data","title":"Background Data","text":"DocTestSetup = quote\n    using GaPSE\nend","category":"page"},{"location":"BackgroundData/#Background-functions","page":"Background Data","title":"Background functions","text":"","category":"section"},{"location":"BackgroundData/","page":"Background Data","title":"Background Data","text":"GaPSE.f0\nGaPSE.D0  \nGaPSE.‚Ñã0 \n\nGaPSE.BackgroundData","category":"page"},{"location":"BackgroundData/#GaPSE.f0","page":"Background Data","title":"GaPSE.f0","text":" const f0 :: Float64\n\nLinear growth rate at present time. Its value is equal to:\n\n     f_0 simeq 05126998572951\n\n\n\n\n\n","category":"constant"},{"location":"BackgroundData/#GaPSE.D0","page":"Background Data","title":"GaPSE.D0","text":" const D0 :: Float64\n\nLinear growth factor at present time. Its value is equal to:\n\n     D_0 = 10\n\n\n\n\n\n","category":"constant"},{"location":"BackgroundData/#GaPSE.‚Ñã0","page":"Background Data","title":"GaPSE.‚Ñã0","text":" const ‚Ñã0 :: Float64\n\nComoving Hubble constant at present time. Its value is, in natural system (where the speed of light c=1):  mathcalH_0 simeq 3335641times10^-4  h_0^-1mathrmMpc\n\n\n\n\n\n","category":"constant"},{"location":"BackgroundData/#GaPSE.BackgroundData","page":"Background Data","title":"GaPSE.BackgroundData","text":" BackgroundData(\n      z::Vector{Float64}\n      conftime::Vector{Float64}\n      comdist::Vector{Float64}\n      angdist::Vector{Float64}\n      lumdist::Vector{Float64}\n      D::Vector{Float64}\n      f::Vector{Float64}\n      ‚Ñã::Vector{Float64}\n      ‚Ñã_p::Vector{Float64})\n\nStruct that contains all the relevant cosmological information for future computations. The data are stored with increasing distance values  (so the first ones are associated to z=0). It is internally used in Cosmology.\n\nArguments\n\nz::Vector{Float64} : redshifts (adimensionals).\nconftime::Vector{Float64} : conformal times, measured in [Mpc/h].\ncomdist::Vector{Float64} : comoving distances, measured in [Mpc/h].\nangdist::Vector{Float64} : angular diameter distances, measured in [Mpc/h].\nlumdist::Vector{Float64} : luminosity distances, measured in [Mpc/h].\nD::Vector{Float64} : linear growth factors, normalized to 1.0 at the present day (adimensional).\nf::Vector{Float64} : linear growth rates (adimensional).\n‚Ñã::Vector{Float64} : comoving Hubble parameters, measured in [h/Mpc].\n‚Ñã_p::Vector{Float64} : derivatives of the comoving Hubble parameter wrt the conformal time. It is here manually computed with the Dierckx function derivative.\n\nConstructors\n\nBackgroundData(file::String, z_max; names = NAMES_BACKGROUND, h = 0.7)\n\nfile::string : input file where the data are stored; it is expected that such file is a background output of the CLASS program (link: https://github.com/lesgourg/class_public)\nz_max : the maximum redhsift we are interested in our analysis. The constructor will store the data necessary for a study only in 0 < z < z_max, for optimisation purposes (More precisely, the maximum distance stored will be 3*z_max).\nnames = NAMES_BACKGROUND : the column names of the file. If the colum order change from the default one NAMES_BACKGROUND, you must set as input the vector of string with the correct one, with the SAME names. They are, with the default order:\n[\"z\", \"proper time [Gyr]\", \"conf. time [Mpc]\", \"H [1/Mpc]\", \"comov. dist.\", \"ang.diam.dist.\", \"lum. dist.\", \"comov.snd.hrz.\", \"(.)rhog\", \"(.)rhob\", \"(.)rhocdm\", \"(.)rholambda\", \"(.)rhour\", \"(.)rhocrit\", \"gr.fac. D\", \"gr.fac. f\"]\nh = 0.7 : the adimensional hubble constant. By default, CLASS background data are measured with it nuymerically expressed (so distances are measured in Mpc, for example), while this code works with h in the unit of measure (so distances are measured in Mpc/h, for example). Change this value to 1.0 if the input data do not have this issue, or to your value of interest  (0.67, 0.5, ...).\n\nSee also: CosmoParams, Cosmology\n\n\n\n\n\n","category":"type"},{"location":"CosmoUtils/","page":"Cosmology Utilities","title":"Cosmology Utilities","text":"DocTestSetup = quote\n    using GaPSE\nend","category":"page"},{"location":"CosmoUtils/#The-Cosmology-Utilities","page":"Cosmology Utilities","title":"The Cosmology Utilities","text":"","category":"section"},{"location":"CosmoUtils/","page":"Cosmology Utilities","title":"Cosmology Utilities","text":"GaPSE.func_z_eff\nGaPSE.s\nGaPSE.Œº\nGaPSE.s2\nGaPSE.y\nGaPSE.œï\nGaPSE.W\nGaPSE.V_survey\nGaPSE.A\nGaPSE.A_prime","category":"page"},{"location":"CosmoUtils/#GaPSE.func_z_eff","page":"Cosmology Utilities","title":"GaPSE.func_z_eff","text":" func_z_eff(s_min, s_max, z_of_s) :: Float64\n\nReturn the effective redshift z_mathrmeff, calcuated as follows:\n\nbeginsplit\nz_mathrmeff = \n    frac\n        int mathrmd^3mathbfs  phi^2(mathbfs)  z(s)\n     \n         int mathrmd^3mathbfs phi^2(mathbfs) \n       = frac\n          int_0^infty mathrmds   s^2  phi^2(s)  z(s) times\n          int_4pimathrmd^2hatmathbfs  W^2(hatmathbfs)\n      \n          int_0^infty mathrmds  s^2  phi^2(s)times\n          int_4pimathrmd^2hatmathbfs  W^2(hatmathbfs)\n       5pt\n      = frac\n          int_0^infty mathrmds   s^2  phi^2(s)  z(s)\n      \n          int_0^infty mathrmds  s^2  phi^2(s)\n       4pt\n      = frac3s_mathrmmax^3 - s_mathrmmin^3 \n          int_s_mathrmmin^s_mathrmmax mathrmds   s^2  z(s)\nendsplit\n\nwhere we have used our assuption on separability of the window function\n\n     phi(mathbfs) = phi(s)  W(hats)\n\nand their definitions.\n\nSee also: œï, W\n\n\n\n\n\n","category":"function"},{"location":"CosmoUtils/#GaPSE.s","page":"Cosmology Utilities","title":"GaPSE.s","text":" s(s1, s2, y) :: Float64\n\nReturn the value s = sqrts_1^2 + s_2^2 - 2  s_1  s_2  y\n\nSee also: Œº, s2, y\n\n\n\n\n\n","category":"function"},{"location":"CosmoUtils/#GaPSE.Œº","page":"Cosmology Utilities","title":"GaPSE.Œº","text":" Œº(s1, s2, y) :: Float64\n\nReturn the value mu=hatmathbfs_1cdothatmathbfs, defined as:\n\nmu = mu(s_1 s_2 y) = fracy  s_2 - s_1s(s_1 s_2 y) \nquad s(s_1 s_2 y) = sqrts_1^2 + s^2 - 2  s_1  s_2  y\n\nwith y=costheta=hatmathbfs_1cdothatmathbfs and where s is  obtained from the function s\n\nSee also: s, s2, y\n\n\n\n\n\n","category":"function"},{"location":"CosmoUtils/#GaPSE.s2","page":"Cosmology Utilities","title":"GaPSE.s2","text":" s2(s1, s, Œº) :: Float64\n\nReturn the value s_2 = sqrts_1^2 + s^2 + 2  s_1  s  mu\n\nSee also: s, Œº, y\n\n\n\n\n\n","category":"function"},{"location":"CosmoUtils/#GaPSE.y","page":"Cosmology Utilities","title":"GaPSE.y","text":" y(s1, s, Œº) :: Float64\n\nReturn the value y=costheta, defined as:\n\ny = y(s_1 s mu) = fracmu  s + s_1s2(s_1 s mu) \nquad s_2 = sqrts_1^2 + s^2 + 2  s_1  s  mu\n\nwith mu=hatmathbfs_1cdothatmathbfs_2 and  where s_2 is btained from the function s2\n\nSee also: s, Œº, s2\n\n\n\n\n\n","category":"function"},{"location":"CosmoUtils/#GaPSE.œï","page":"Cosmology Utilities","title":"GaPSE.œï","text":" œï(s, s_min, s_max) :: Float64\n\nRadial part of the survey window function. Return 1.0 if is true that s_mathrmmin  s  s_mathrmmax and 0.0 otherwise.\n\nIn this software we made the assuption that the survey window function can be separated into a radial and angular part, i.e.:\n\n     phi(mathbfs) = phi(s)  W(hats)\n\nSee also: W\n\n\n\n\n\n","category":"function"},{"location":"CosmoUtils/#GaPSE.W","page":"Cosmology Utilities","title":"GaPSE.W","text":" W(Œ∏, Œ∏_max) :: Float64\n\nAngular part of the survey window function. Return 1.0 if is true that 00 leq theta  theta_mathrmmax and 0.0 otherwise. It is implicitly assumed an azimutal simmetry of the survey.\n\nIn this software we made the assuption that the survey window function can be separated into a radial and angular part, i.e.:\n\n     phi(mathbfs) = phi(s)  W(hats)\n\nSee also: œï\n\n\n\n\n\n","category":"function"},{"location":"CosmoUtils/#GaPSE.V_survey","page":"Cosmology Utilities","title":"GaPSE.V_survey","text":" V_survey(s_min, s_max, Œ∏_max) :: Float64\n\nReturn the volume of a survey with azimutal simmetry, i.e.:\n\nbeginsplit\n    V(s_mathrmmax s_mathrmmin theta_mathrmmax) =  C_mathrmup - C_mathrmdown + TC \n    C_mathrmup = fracpi3 s_mathrmmax^3  \n        (1 - costheta_mathrmmax)^2  (2 + costheta_mathrmmax) \n    C_mathrmdown = fracpi3 s_mathrmmin^3  \n        (1 - costheta_mathrmmax)^2  (2 + costheta_mathrmmax) \n    TC = fracpi3 (s_mathrmmax^2 + s_mathrmmin^2 + \n        s_mathrmmax s_mathrmmin)   (s_mathrmmax - s_mathrmmin) \n        costheta_mathrmmax sin^2theta_mathrmmax\nendsplit\n\n\n\n\n\n","category":"function"},{"location":"CosmoUtils/#GaPSE.A","page":"Cosmology Utilities","title":"GaPSE.A","text":" A(s_min, s_max, Œ∏_max) :: Float64\n\nReturn the Power Spectrum multipole normalization coefficient A, i.e.:\n\n     A(s_mathrmmax s_mathrmmin theta_mathrmmax)= \n     frac\n          V(s_mathrmmax s_mathrmmin theta_mathrmmax)\n     4  pi^2\n\nwhere V(s_mathrmmax s_mathrmmin theta_mathrmmax) is the  survey volume.\n\nPay attention: this is NOT used for the normalization of PS, see instead A_prime\n\nSee also: V_survey\n\n\n\n\n\n","category":"function"},{"location":"CosmoUtils/#GaPSE.A_prime","page":"Cosmology Utilities","title":"GaPSE.A_prime","text":" A_prime :: Float64\n\nIt's the Power Spectrum multipole normalization coefficient A^, i.e.:\n\n     A^ = frac3  A (s_mathrmmax^3 - s_mathrmmin^3) = \n     frac14pi\n\nSee also: A, V_survey\n\n\n\n\n\n","category":"constant"},{"location":"OtherUtils/","page":"Other Utilities","title":"Other Utilities","text":"DocTestSetup = quote\n    using GaPSE\nend","category":"page"},{"location":"OtherUtils/#Other-utilities","page":"Other Utilities","title":"Other utilities","text":"","category":"section"},{"location":"OtherUtils/","page":"Other Utilities","title":"Other Utilities","text":"GaPSE.check_compatible_dicts","category":"page"},{"location":"OtherUtils/#GaPSE.check_compatible_dicts","page":"Other Utilities","title":"GaPSE.check_compatible_dicts","text":"check_compatible_dicts(ref::Dict, b::Dict, name::String = \"NO-NAME\")\n\nCompare the field of two Dict and check if the second one (b) is \"compatible\" with the first one (ref), i.e.:\n\nchecks if each of the key in b is also a key of ref;\nfor each key of b:\nif typeof(ref[key]) <: Real and !(typeof(ref[k]) <: Union{Bool, Integer}), checks that typeof(b[k]) <: Real && typeof(b[k]) ‚â† Bool\notherwise, checks that typeof(b[k]) == typeof(ref[k])\n\nIf someone of the check mentioned is false, raise an AssertionError, otherwise return nothing.  The string name is only used inside the AssertionError messages for the correct name of the input b dictionary.\n\n\n\n\n\n","category":"function"},{"location":"PowerSpectrum/","page":"Power Spectrum Multipoles","title":"Power Spectrum Multipoles","text":"DocTestSetup = quote\n    using GaPSE\nend","category":"page"},{"location":"PowerSpectrum/#The-Power-Spectrum-multipole-computation","page":"Power Spectrum Multipoles","title":"The Power Spectrum multipole computation","text":"","category":"section"},{"location":"PowerSpectrum/","page":"Power Spectrum Multipoles","title":"Power Spectrum Multipoles","text":"GaPSE.PS_multipole\nGaPSE.print_PS_multipole","category":"page"},{"location":"PowerSpectrum/#GaPSE.PS_multipole","page":"Power Spectrum Multipoles","title":"GaPSE.PS_multipole","text":" PS_multipole(input::String; kwargs...\n      ) ::Tuple{Vector{Float64}, Vector{Float64}}\n\n PS_multipole(ss, fs;\n      int_s_min::Float64=1e-1, int_s_max::Float64=1e3,\n      epl::Bool=true,\n      N_left::Integer=12, N_right::Integer=12,\n      p0_left=[-2.0, 1.0], p0_right=[-2.0, 1.0],\n      kwargs...)\n\n PS_multipole(f_in;\n      int_s_min::Float64=1e-1, int_s_max::Float64=1e3,\n      L::Integer=0, N::Integer=1024, pr::Bool=true,\n      k0::Union{Nothing,Float64}=nothing,\n      right::Union{Float64,Nothing}=nothing)\n\nReturn the L-order PS multipole through the following Fast Fourier Transform and the effective redshift approximation:\n\nP_L(k) = frac2 L + 1A^ (-i)^L  phi(s_mathrmeff) int_0^infty \n        mathrmd s  s^2  j_L(ks)  f_mathrmin(s)  \n        quad  A^ = frac14pi\n\nThe former method takes the name of the file where the TPCF multipole in exam is saved in, opens that file and pass the xs and  ys vector of values to the second method. All the keyword- arguments given to the first method are directly transferred to the second one.\n\nIn the second method, you have to pass the xs and ys values of the TPCF you want to exam. Internally, if epl==true the data are fitted with two power laws at the edges, creating a EPLs struct that is passed to the third method. The great advantage is that the integration can be extended over the limits imposed by the vector themself, increasing by far the precision of the PS computation.\n\nIn the last method, you have to give its function/spline f_in.\n\nIt's recommended to use either the first or the second method.\n\nThe analytical expression previously showed can be easily obtained from the  standard one:\n\nbeginsplit\n    P_L(k) = frac2 L + 1A (-i)^L  \n        int_0^infty mathrmd s_1  s_1^2 \n        int_0^infty mathrmd s  s^2 \n        int_-1^+1 mathrmd mu \n        j_L(ks)  xi(s_1 s mu)  phi(s_1)  phi(s_2) \n        mathcalL_L(mu) Fleft(fracss_1 mu right) \n        mathrmwith  s_2 = s_2(s_1 s Œº) = sqrts_1^2 + s^2 + 2s_1smu\n         \n         quad A(s_mathrmmax s_mathrmmin theta_mathrmmax) \n        frac\n          V(s_mathrmmax s_mathrmmin theta_mathrmmax)\n          4  pi^2\nendsplit\n\nwith the definition\n\nf_mathrmin(s_1 s) =  int_-1^+1 mathrmd mu \n        xi(s_1 s mu)  phi(s_2) \n        mathcalL_L(mu)  Fleft(fracss_1 mu right)\n\nand the application of the effective redshift approximation.\n\nThe computation is made through the xicalc function of the  TwoFAST Julia package. Note that in the computation the integration range 0leq s leq infty  is reduced to int_s_min ‚â§ s ‚â§ int_s_max`\n\nOptional arguments\n\nint_s_min::Float64 = 1e-1 and int_s_max::Float64 = 1e3 : extremes of integration. Do not worry if the input TPCF is not defined in all the  integration range: it will be fitted with two power laws at its extremes,  thanks to the function EPLs\nN_left::Integer = 12 and N_right::Integer = 12 : number of points from left right edges to be used for the power law fitting in EPLs. They matters only if in the given input file Œæ is not defined until the extremes of integration int_s_min and int_s_max\nL::Integer = 0: order of the Legendre polynomial to be used; note that  the multipole order L must be the same of the input TPCF in exam!  Otherwise, the results would have no sense at all!\npr::Bool = true : do you want the progress bar showed on screen, in order to  check the time needed for the computation? (true recommended)\nN::Integer = 1024 : number of points to be returned by xicalc\n\nReturns\n\nA Tuple{Vector{Float64}, Vector{Float64}} with:\n\nthe k values vector as first element;\nthe correspoding PS pk values vector as second one.\n\nSee also: V_survey, A, A_prime, EPLs,  print_PS_multipole\n\n\n\n\n\n","category":"function"},{"location":"PowerSpectrum/#GaPSE.print_PS_multipole","page":"Power Spectrum Multipoles","title":"GaPSE.print_PS_multipole","text":" print_PS_multipole(input::String, out::String;\n      L::Integer = 0, N::Integer = 1024,\n      pr::Bool = true, kwargs...)\n\nTakes in input a filename input where is stored a TPCF multipole, calculate the L-order PS multipole through the following Fast Fourier Transform and the effective redshift approximation\n\nP_L(k) = frac2 L + 1A^ (-i)^L  phi(s_mathrmeff) int_0^infty \n        mathrmd s  s^2  j_L(ks)  f_mathrmin(s)  \n        quad  A^ = frac14pi\n\nand save it in the file out, together with the options used for the computation.\n\nOptional arguments\n\nL::Integer = 0: order of the Legendre polynomial to be used; note that  the multipole order L must be the same of the input TPCF in exam!  Otherwise, the results would have no sense at all!\npr::Bool = true : do you want the progress bar showed on screen, in order to  check the time needed for the computation? (true recommended)\nN::Integer = 1024 : number of points to be returned by xicalc\nkwargs... : other keyword arguments that will be passed to PS_multipole\n\nSee also: V_survey, A, A_prime, EPLs, PS_multipole\n\n\n\n\n\n","category":"function"},{"location":"","page":"Introduction","title":"Introduction","text":"DocTestSetup = quote\n    using GaPSE\nend","category":"page"},{"location":"#GaPSE.jl-:-a-Galaxy-Power-Spectrum-Estimator","page":"Introduction","title":"GaPSE.jl : a Galaxy Power Spectrum Estimator","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"This is the documentation of GaPSE.jl package, an implementation of a Galaxy Power Spectrum Estimator written in Julia.","category":"page"},{"location":"#Documentation","page":"Introduction","title":"Documentation","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The documentation was built using Documenter.jl.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"using Dates # hide\nprintln(\"Documentation built on $(now()) using Julia $(VERSION).\") # hide","category":"page"},{"location":"#Brief-description","page":"Introduction","title":"Brief description","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Measurements of the clustering of galaxies in Fourier space, at low wavenumbers, offer a window into the early Universe via the possible presence of scale dependent bias generated by Primordial Non Gaussianities [1] [2]. On such large scales, a Newtonian treatment of density of density perturbations might not be sufficient to describe the measurements, and a fully relativistic calculation should be employed.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"In this program, we compute, for a given input matter power spectum (obtained from CLASS), all the GR effects two point auto-correlation and cross-correlation functions, for an arbitrary multipole order. This project, and the analytical expressions used for the TPCFs, are based on the article of Emanuele Castorina and Enea Di Dio [3]. ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The most confortable way to use this code is through the Jupyter Notebooks: some .ipynb is already provided in the main directory, and we encourage you to follow the TUTORIAL.ipynb file first. The basic structure of the program and the most important functions are there presented.","category":"page"},{"location":"#Licence","page":"Introduction","title":"Licence","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"This software is under the GNU 3.0 General Public Licence. See the file LICENCE.md.","category":"page"},{"location":"#Acknowledgements","page":"Introduction","title":"Acknowledgements","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"This package make extensive use of Spline1D (from the  Dierckx[4] Julia package) and the Spherical Bessel Transform function xicalc (from the  TwoFAST[5] Julia package).","category":"page"},{"location":"#References","page":"Introduction","title":"References","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"<a id=\"1\">[1]</a>  Dalal, Dor√© et al., Imprints of primordial non-Gaussianities on large-scale structure (2008), American Physical Society, DOI: 10.1103/PhysRevD.77.123514,  url: https://journals.aps.org/prd/abstract/10.1103/PhysRevD.77.123514","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"<a id=\"2\">[2]</a>  Slosar, Hirata et al., Constraints on local primordial non-Gaussianity from large scale structure (2008), Journal of Cosmology and Astroparticle Physics, DOI: 10.1088/1475-7516/2008/08/031, url: https://doi.org/10.1088/1475-7516/2008/08/031","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"<a id=\"3\">[3]</a>  Castorina, Di Dio, The observed galaxy power spectrum in General Relativity (2022), Journal of Cosmology and Astroparticle Physics, DOI: 10.1088/1475-7516/2022/01/061, url: https://doi.org/10.1088/1475-7516/2022/01/061","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"<a id=\"4\">[4]</a> Paul Dierckx, Curve and Surface Fitting with Splines (1993), Oxford University Press","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"<a id=\"5\">[5]</a> Gebhardt, Jeong et al, Fast and accurate computation of projected two-point functions (2018), American Physical Society, DOI: 10.1103/PhysRevD.97.023504, url: https://link.aps.org/doi/10.1103/PhysRevD.97.023504","category":"page"},{"location":"#Contents","page":"Introduction","title":"Contents","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"#Index","page":"Introduction","title":"Index","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"","category":"page"}]
}
