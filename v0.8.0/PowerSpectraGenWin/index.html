<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Power Spectra for a generic window ¬∑ GaPSE.jl</title><meta name="title" content="Power Spectra for a generic window ¬∑ GaPSE.jl"/><meta property="og:title" content="Power Spectra for a generic window ¬∑ GaPSE.jl"/><meta property="twitter:title" content="Power Spectra for a generic window ¬∑ GaPSE.jl"/><meta name="description" content="Documentation for GaPSE.jl."/><meta property="og:description" content="Documentation for GaPSE.jl."/><meta property="twitter:description" content="Documentation for GaPSE.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">GaPSE.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><span class="tocitem">The basic structure</span><ul><li><a class="tocitem" href="../BackgroundData/">Background Data</a></li><li><a class="tocitem" href="../CosmoParams/">Cosmology Parameters</a></li><li><a class="tocitem" href="../Cosmology/">Cosmology Struct</a></li></ul></li><li><span class="tocitem">The window function F and its integration</span><ul><li><a class="tocitem" href="../WindowF/">Window F</a></li><li><a class="tocitem" href="../WindowFIntegrated/">Integrated Window F</a></li></ul></li><li><span class="tocitem">Calculating TPCFs multipoles</span><ul><li><input class="collapse-toggle" id="menuitem-4-1" type="checkbox"/><label class="tocitem" for="menuitem-4-1"><span class="docs-label">GNC</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../GNC_Correlations_1/">GNC TPCFs</a></li><li><a class="tocitem" href="../GNC_Correlations_2/">GNC TPCFs</a></li><li><a class="tocitem" href="../GNC_Correlations_3/">GNC TPCFs</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-2" type="checkbox"/><label class="tocitem" for="menuitem-4-2"><span class="docs-label">LD</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../LD_Correlations_1/">LD TPCFs</a></li><li><a class="tocitem" href="../LD_Correlations_2/">LD TPCFs</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-3" type="checkbox"/><label class="tocitem" for="menuitem-4-3"><span class="docs-label">GNCxLD</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../GNCxLD_Correlations_1/">GNCxLD TPCFs</a></li><li><a class="tocitem" href="../GNCxLD_Correlations_2/">GNCxLD TPCFs</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-4" type="checkbox"/><label class="tocitem" for="menuitem-4-4"><span class="docs-label">LDxGNC</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../LDxGNC_Correlations_1/">LDxGNC TPCFs</a></li><li><a class="tocitem" href="../LDxGNC_Correlations_2/">LDxGNC TPCFs</a></li></ul></li></ul></li><li><a class="tocitem" href="../PlaneParallelApprox/">Calculating TPCFs with the PP Approximation</a></li><li><a class="tocitem" href="../PowerSpectra/">Calculating Power Spectra</a></li><li class="is-active"><a class="tocitem" href>Power Spectra for a generic window</a><ul class="internal"><li><a class="tocitem" href="#Multipoles-Q_l1-of-the-toy-model-window-function"><span>Multipoles Q_l1 of the toy-model window function</span></a></li><li><a class="tocitem" href="#Creating-a-XiMultipole-struct"><span>Creating a XiMultipole struct</span></a></li><li><a class="tocitem" href="#The-Power-Spectrum-for-a-GenWin"><span>The Power Spectrum for a GenWin</span></a></li></ul></li><li><a class="tocitem" href="../PNG/">implication on PNG</a></li><li><span class="tocitem">Utilities</span><ul><li><a class="tocitem" href="../Dicts/">Dictionaries and names</a></li><li><a class="tocitem" href="../MathUtils/">Mathematical Utilities</a></li><li><a class="tocitem" href="../CosmoUtils/">Cosmology Utilities</a></li><li><a class="tocitem" href="../IPSTools/">Input Power Spectrum Tools</a></li><li><a class="tocitem" href="../OtherUtils/">Other Utilities</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Power Spectra for a generic window</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Power Spectra for a generic window</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/foglienimatteo/GaPSE.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands">ÔÇõ</span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/foglienimatteo/GaPSE.jl/blob/main/docs/src/PowerSpectraGenWin.md" title="Edit source on GitHub"><span class="docs-icon fa-solid">ÔÅÑ</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Power-Spectrum-for-a-generic-window-fuction"><a class="docs-heading-anchor" href="#Power-Spectrum-for-a-generic-window-fuction">Power Spectrum for a generic window fuction</a><a id="Power-Spectrum-for-a-generic-window-fuction-1"></a><a class="docs-heading-anchor-permalink" href="#Power-Spectrum-for-a-generic-window-fuction" title="Permalink"></a></h1><h2 id="Multipoles-Q_l1-of-the-toy-model-window-function"><a class="docs-heading-anchor" href="#Multipoles-Q_l1-of-the-toy-model-window-function">Multipoles Q_l1 of the toy-model window function</a><a id="Multipoles-Q_l1-of-the-toy-model-window-function-1"></a><a class="docs-heading-anchor-permalink" href="#Multipoles-Q_l1-of-the-toy-model-window-function" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GaPSE.WindowFIntegrated_multipole" href="#GaPSE.WindowFIntegrated_multipole"><code>GaPSE.WindowFIntegrated_multipole</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">WindowFIntegrated_multipole(
        s, windowfint::GaPSE.WindowFIntegrated;
        s_min, s_max,
        L::Int=0, alg::Symbol=:lobatto,
        N_lob::Int=100, N_trap::Int=200,
        atol_quad::Float64=0.0, rtol_quad::Float64=1e-2,
        enhancer::Float64=1e6,
        )</code></pre><p>Evaluate the multipole of order <code>L</code> of the input Integrated Window Function <code>windowfint</code> in the  input comoving distance <code>s</code>.  We remember that all the distances are measured in <span>$h_0^{-1}\mathrm{Mpc}$</span>.</p><p>The analytical expression of the Integrated Window Function multipole <span>$Q_{\ell_1}$</span> is the following:</p><p class="math-container">\[Q_{\ell_1}(s) = 
    \int_{-1}^{1} \mathrm{d}\mu \; \mathcal{L}_{\ell_1}(\mu) 
    \; \mathcal{F}(s, \mu)\]</p><p>where <span>$\mathcal{L}_{\ell_1}$</span> is the Legendre polynomial of order <span>$\ell_1$</span>, <span>$\mu$</span> the  cosine angle, </p><p class="math-container">\[\mathcal{F}(s, \mu) = 
    \int_0^\infty \mathrm{d}s_1 \, \phi(s_1) \,  
    \phi\left(\sqrt{s_1^2 + s^2 + 2 \, s_1 \, s \, \mu}\right) 
    \, F\left(\frac{s}{s_1}, \mu \right)\]</p><p>the integrated window function associated to the window function <span>$F\left(\frac{s}{s_1}, \mu \right)$</span> (check the docstring of <code>WindowF</code> for its definition) and <span>$\phi$</span> the radial window function, obtained by  <code>œï</code>.</p><p><strong>Optional arguments</strong></p><ul><li><p><code>s_min</code> and <code>s_max</code> (mandatory keyword arguments) : min and max comoving distance of the survey; their values will be internally used by </p></li><li><p><code>L::Int = 0</code>: order of the Legendre polynomial to be used</p></li><li><p><code>alg::Symbol = :lobatto</code> : algorithm to be used for the integration; the valid options  are (other values will lead to <code>AssertionError</code>):</p><ul><li><code>:quad</code> -&gt; the integration over <span>$\mu$</span> will be preformed through the Julia function <code>quadgk</code> </li></ul><p>from the <a href="https://github.com/JuliaMath/QuadGK.jl"><code>QuadGK.jl</code></a> Julia package, that uses an adaptive  Gauss-Kronrod quadrature.</p><ul><li><code>:trap</code> -&gt; the integration over <span>$\mu$</span> will be preformed through the Julia function <code>trapz</code> </li></ul><p>from the <a href="https://github.com/francescoalemanno/Trapz.jl"><code>Trapz.jl</code></a> Julia package, that uses the simple trapezoidal rulae.</p><ul><li><code>:lobatto</code> -&gt; the integration over <span>$\mu$</span> will be preformed through the Julia function <code>gausslobatto</code> </li></ul><p>from the <a href="https://github.com/JuliaApproximation/FastGaussQuadrature.jl"><code>FastGaussQuadrature.jl</code></a> Julia package,  that uses the Gauss-Lobatto quadrature. </p></li><li><p><code>N_lob::Int = 100</code> : number of points to be used in the sampling made by the function <code>trapz</code>. Note that these options will have an effect only if you se <code>alg = :quad</code>.</p></li><li><p><code>N_trap::Int = 200</code> : number of points to be used in the sampling made by the function <code>trapz</code>. Note that these options will have an effect only if you se <code>alg = :quad</code>.</p></li><li><p><code>atol_quad::Float64 = 0.0</code> and <code>rtol_quad::Float64 = 1e-2</code>: absolute and relative tolerance to be passed to the function <code>quadgk</code>; it&#39;s recommended not to set <code>rtol_quad &lt; 1e-2</code>  because the time for evaluation increase quickly. Note that these options will have an effect only if you se <code>alg = :quad</code>.</p></li><li><p><code>enhancer::Float64 = 1e6</code>: just a float number used in order to deal better with small numbers;  the returned value is NOT modified by this value, because after a multiplication the internal result is divided by <code>enhancer</code>.</p></li></ul><p>See also: <a href="../WindowFIntegrated/#GaPSE.WindowFIntegrated"><code>WindowFIntegrated</code></a>, <a href="../WindowF/#GaPSE.WindowF"><code>WindowF</code></a>, <a href="../CosmoUtils/#GaPSE.œï"><code>œï</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/foglienimatteo/GaPSE.jl/blob/e601437c432ee08c2009b9fd4aee18390ba3e877/src/WindowF_QMultipoles.jl#L21-L93">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GaPSE.print_map_WindowFIntegrated_multipole" href="#GaPSE.print_map_WindowFIntegrated_multipole"><code>GaPSE.print_map_WindowFIntegrated_multipole</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">print_map_WindowFIntegrated_multipole(
    ss::Vector{Float64},
    windowFint::Union{String,GaPSE.WindowFIntegrated}, out::String;
    s_min, s_max,
    pr::Bool=true, L_max::Int=4, alg::Symbol=:lobatto,
    N_lob::Int=100, N_trap::Int=200,
    atol_quad::Float64=0.0, rtol_quad::Float64=1e-2,
    enhancer::Float64=1e6)

print_map_WindowFIntegrated_multipole(
    s_zs::Vector{Float64},
    windowFint::Union{String,GaPSE.WindowFIntegrated}, out::String,
    file_data::String; z_min, z_max,
    names_bg=GaPSE.NAMES_BACKGROUND, h_0=0.7, kwargs...))

print_map_WindowFIntegrated_multipole(
    windowFint::Union{String,GaPSE.WindowFIntegrated}, out::String,
    file_data::String; z_min, z_max,
    names_bg=GaPSE.NAMES_BACKGROUND, h_0=0.7, N::Int=100, 
    m::Float64=2.1, st::Float64=0.0, kwargs...)</code></pre><p>Evaluate the integrated window function multipoles <span>$Q_{\ell_1}(s)$</span> in a vector of <span>$s$</span> values for all the multipoles <span>$0 \leq \ell_1 \leq L_\mathrm{max}$</span>, and print the results in the <code>out</code> file. The computation of the multipole is performed through <code>WindowFIntegrated_multipole</code>.</p><p>The first method takes as input:</p><ul><li><code>ss::Vector{Float64}</code> :  the vector of s points where to  sample the integrated window function multipoles <span>$Q_{\ell_1}$</span>.<code>ss</code> must be a float vector of  increasing comoving distance values (so each element must be ‚â• 0); the first and last values  ARE NOT RELATED to <code>s_min</code> and <code>s_max</code>.</li><li><code>windowFint::Union{String,WindowFIntegrated}</code>, i.e. the integrated window function itself; it can be  passed as the namefile where the integrated window is stored in (that will be opened with <code>WindowFIntegrated</code>)  or as a <code>WindowFIntegrated</code> struct directly.</li><li><code>out::String</code> : the name of the output file</li><li><code>s_min</code> and <code>s_max</code> (keyword arguments) : min and max comoving distance of the survey; their values will be internally used by </li></ul><p>The second method takes as input the min and max redshifts of the survey (<code>z_min</code>and <code>z_max</code>), the vector of redshifts <code>zs::Vector{Float64}</code> for the integrated window function sampling, <code>windowFint</code>  as before and the <code>file_data</code> where can be found the association <span>$z \rightarrow s(z)$</span>.  Such file must have the structure of the  background data produced by the CLASS (link: https://github.com/lesgourg/class_public) code. Note that also <code>zs</code> musyt be a float vector of increasing redshift values (so each element must be ‚â• 0). This method internally recalls the first one, so the other <code>kwargs...</code> are in common.</p><p>The third method takes as input the min and max redshifts of the survey (<code>z_min</code>and <code>z_max</code>) and the same  input as the second method (<code>windowF</code>, <code>out</code> and <code>file_data</code>) but NOT THE REDSHIFT SAMPLING VECTOR <code>zs</code>. The sampling will be internally made linearly from <span>$s = \mathrm{st}$</span>(where <code>st::Float64 = 0.0</code> is a  keyword argument) to <span>$s = m \, s_{\mathrm{max}}$</span>, where <code>s_max</code> is the comoving distance associated to  <code>z_max</code> (for the data stored in <code>file_data</code>) and <code>m::Float64 = 2.1</code> a coefficient that we  suggest to set equals to <code>2 &lt; m &lt; 3</code>. <code>N::Int = 100</code> is the number of <code>s</code> values used for the sampling in the interval  <span>$[0, m \, s_{\mathrm{max}}]$</span>. This method internally recalls the first one, so the other <code>kwargs...</code> are in common.</p><p>The analytical expression for the integrated window function is the following:</p><p class="math-container">\[Q_{\ell_1}(s) = 
    \int_{-1}^{1} \mathrm{d}\mu \; \mathcal{L}_{\ell_1}(\mu) 
    \; \mathcal{F}(s, \mu)\]</p><p>where <span>$s$</span> is the comoving distance, <span>$\mu$</span> the cosine angle, <span>$\mathcal{L}_{\ell_1}$</span> the Legendre polynomial of order <span>$\ell_1$</span> and <span>$\mathcal{F}(x, Œº)$</span> the  integrated window function. Check the documentation of <code>WindowFIntegrated</code> for its definition. We remember that all the distances are measured in <span>$h_0^{-1}\mathrm{Mpc}$</span>.</p><p><strong>Example</strong></p><p>julia&gt; windowfint = GaPSE.WindowFIntegrated(PATH<em>TO</em>GAPSE<em>&quot;data/IntegrF<em>REFERENCE</em>pi2<em>z115.txt&quot;); julia&gt; GaPSE.print</em>map<em>WindowFIntegrated</em>multipole(windowfint, &quot;my<em>Ql</em>multipoles.txt&quot;,      PATH<em>TO</em>GAPSE</em>&quot;data/WideA<em>ZA</em>background.dat&quot;; z<em>min = 1.0, z</em>max=1.5, st = 1.0, N=500, pr=false) julia&gt; run(<code>head -n 20  $(DIR*&quot;my_Ql_multipoles.txt&quot;)</code>) ###############</p><p><strong>GaPSE</strong></p><p>############### </p><p><strong></strong></p><p><strong>This is an integration map of the Q<em>{l</em>1} multipoles, defined as:</strong></p><p><strong>Q<em>{l</em>1}(s<em>1, s \mu) = \int</em>{-1}^{+1} \mathrm{d}\mu \mathcal{L}<em>{l</em>1}(\mu) \mathcal{F}(s, \mu)</strong></p><p><strong>\mathcal{F}(s, \mu) = \int<em>0^{\infty} \mathrm{d}s</em>1 s<em>1^2 \phi(s</em>1) \phi(\sqrt(s<em>1^2 + s^2 + 2 s</em>1 s \mu)) F(s/s_1, \mu)</strong></p><p><strong>where \mathcal{L}<em>{l</em>1}(\mu) is tre Legendre polynomial if order l1 and</strong></p><p><strong>F(x, \mu) is the window function considered (for its analytical definition, check the code).</strong></p><p><strong></strong></p><p><strong></strong></p><p><strong>Time needed for this computation [in s]: 27.256186962127686</strong></p><p><strong>The keyword arguments were:</strong></p><p><strong></strong></p><p><strong>s [h<em>0^{-1} Mpc]      Q</em>{l<em>1=0}      Q</em>{l<em>1=1}      Q</em>{l<em>1=2}      Q</em>{l<em>1=3}      Q</em>{l_1=4}</strong></p><p>1.0      4.1857800000750543e11      -4.377435879373042e7      -5.084259164821501e8      1.2380785453994218e6      -3.641597411371149e8       13.852533751787348      4.1473071900503394e11      -6.063857839848524e8      -1.342493986435839e9      1.7150523594728626e7      -2.0225033264194965e8 ...            ...            ...            ...            ...            ...</p><p><strong>Optional arguments</strong></p><p>As optional arguments of the first method:</p><ul><li><p><code>s_min</code> and <code>s_max</code> (mandatory keyword arguments) : min and max comoving distance of the survey; their values will be internally used by </p></li><li><p><code>pr::Bool = true</code> : do you want to see the progress-bar of the computation?</p></li><li><p><code>L_max::Int64 = 4</code> : maximum multipole order to be computed</p></li><li><p><code>alg::Symbol = :lobatto</code> : algorithm to be used for the integration; the valid options  are (other values will lead to <code>AssertionError</code>):</p><ul><li><code>:quad</code> -&gt; the integration over <span>$\mu$</span> will be preformed through the Julia function <code>quadgk</code> </li></ul><p>from the <a href="https://github.com/JuliaMath/QuadGK.jl"><code>QuadGK.jl</code></a> Julia package, that uses an adaptive  Gauss-Kronrod quadrature.</p><ul><li><code>:trap</code> -&gt; the integration over <span>$\mu$</span> will be preformed through the Julia function <code>trapz</code> </li></ul><p>from the <a href="https://github.com/francescoalemanno/Trapz.jl"><code>Trapz.jl</code></a> Julia package, that uses the simple trapezoidal rulae.</p><ul><li><code>:lobatto</code> -&gt; the integration over <span>$\mu$</span> will be preformed through the Julia function <code>gausslobatto</code> </li></ul><p>from the <a href="https://github.com/JuliaApproximation/FastGaussQuadrature.jl"><code>FastGaussQuadrature.jl</code></a> Julia package,  that uses the Gauss-Lobatto quadrature. </p></li><li><p><code>N_lob::Int = 100</code> : number of points to be used in the sampling made by the function <code>trapz</code>. Note that these options will have an effect only if you se <code>alg = :quad</code>.</p></li><li><p><code>N_trap::Int = 200</code> : number of points to be used in the sampling made by the function <code>trapz</code>. Note that these options will have an effect only if you se <code>alg = :quad</code>.</p></li><li><p><code>atol_quad::Float64 = 0.0</code> and <code>rtol_quad::Float64 = 1e-2</code>: absolute and relative tolerance to be passed to the function <code>quadgk</code>; it&#39;s recommended not to set <code>rtol_quad &lt; 1e-2</code>  because the time for evaluation increase quickly. Note that these options will have an effect only if you se <code>alg = :quad</code>.</p></li><li><p><code>enhancer::Float64 = 1e6</code>: just a float number used in order to deal better with small numbers;  the returned value is NOT modified by this value, because after a multiplication the internal result is divided by <code>enhancer</code>.</p></li></ul><p>The optional arguments given to the second method will be directly given to the first one. The only two exceptions are:</p><ul><li><p><code>s_min</code> and <code>s_max</code> (mandatory keyword arguments) : min and max redshift of the survey; their values will be internally coverted to comoving distances and passed to the first method</p></li><li><p><code>names = NAMES_BACKGROUND</code> : the column names of the <code>file_data</code>. If the colum order change from the default one <code>NAMES_BACKGROUND</code>, you must set as input the vector of string with the correct one, with the SAME names. They are, with the default order:</p><p>[&quot;z&quot;, &quot;proper time [Gyr]&quot;, &quot;conf. time [Mpc]&quot;, &quot;H [1/Mpc]&quot;, &quot;comov. dist.&quot;, &quot;ang.diam.dist.&quot;, &quot;lum. dist.&quot;, &quot;comov.snd.hrz.&quot;, &quot;(.)rho<em>g&quot;, &quot;(.)rho</em>b&quot;, &quot;(.)rho<em>cdm&quot;, &quot;(.)rho</em>lambda&quot;, &quot;(.)rho<em>ur&quot;, &quot;(.)rho</em>crit&quot;, &quot;gr.fac. D&quot;, &quot;gr.fac. f&quot;]</p></li><li><p><code>h = 0.7</code> : the adimensional hubble constant. By default, CLASS background data are measured with it numerically expressed (so distances are measured in <code>Mpc</code>, for example), while this code works with <code>h</code> in the unit of measure (so distances are measured in <code>Mpc/h</code>, for example). Change this value to <code>1.0</code> if the input data do not have this issue, or to your value of interest  (<code>0.67</code>, <code>0.5</code>, ...).</p></li></ul><p>The optional arguments given to the third method will be directly given to the first one again. The only two exceptions are:</p><ul><li><p><code>names_bg=GaPSE.NAMES_BACKGROUND</code> and <code>h_0=0.7</code> : same as for the second method</p></li><li><p><code>N::Int=100</code> : number of points to be used in the liearly spaced comoving distance vector</p></li><li><p><code>st::Float64=0.0</code> : starting comoving distance of the vector</p></li><li><p><code>m:Float64 = 2.1</code> : coefficient that set the maximum comoving distance of the vector, equals to <span>$m * s_max$</span>, where <code>s_max</code> is the comoving distance associated to the redhsift <code>z_max</code></p></li></ul><p>See also:  <a href="#GaPSE.WindowFIntegrated_multipole"><code>WindowFIntegrated_multipole</code></a>, <a href="../WindowFIntegrated/#GaPSE.WindowFIntegrated"><code>WindowFIntegrated</code></a>,  <a href="../WindowF/#GaPSE.WindowF"><code>WindowF</code></a>, <a href="../CosmoUtils/#GaPSE.œï"><code>œï</code></a>, <a href="../BackgroundData/#GaPSE.BackgroundData"><code>BackgroundData</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/foglienimatteo/GaPSE.jl/blob/e601437c432ee08c2009b9fd4aee18390ba3e877/src/WindowF_QMultipoles.jl#L264-L430">source</a></section></article><h2 id="Creating-a-XiMultipole-struct"><a class="docs-heading-anchor" href="#Creating-a-XiMultipole-struct">Creating a XiMultipole struct</a><a id="Creating-a-XiMultipole-struct-1"></a><a class="docs-heading-anchor-permalink" href="#Creating-a-XiMultipole-struct" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GaPSE.XiMultipoles" href="#GaPSE.XiMultipoles"><code>GaPSE.XiMultipoles</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">XiMultipoles(
    comdist::Vector{Float64}
    multipoles::Vector{Vector{Float64}}
)</code></pre><p>Stores the multipoles of a generic Two-Point Correlation Function.</p><p><strong>Constructors</strong></p><pre><code class="nohighlight hljs">XiMultipoles(file::String; comments::Bool=true, xdt::DataType=Float64, ydt::DataType=Float64)</code></pre><p>Read the file <code>file</code> and create a <code>XiMultipoles</code> struct having</p><ul><li>as first element the comoving distances stored in the first column (with the input type <code>xdt</code>)</li><li>as second element a vector that contains all the following columns  (with the input type <code>ydt</code>), which are the multipoles <code>L=0,1,2,...</code> of the TPCF considered</li></ul><p>If the file start with comments (lines starting with #), set <code>comments = true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/foglienimatteo/GaPSE.jl/blob/e601437c432ee08c2009b9fd4aee18390ba3e877/src/PowerSpectraGenWin.jl#L233-L251">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GaPSE.create_file_for_XiMultipoles" href="#GaPSE.create_file_for_XiMultipoles"><code>GaPSE.create_file_for_XiMultipoles</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">create_file_for_XiMultipoles(out::String, names::Vector{String}, 
    effect::Union{String, Integer}, group::String=&quot;GNC&quot;; 
    comments::Bool=true, xdt::DataType=Float64, ydt::DataType=Float64)</code></pre><p>Read the column number <code>effect</code> (if is an Integer) or the one corresponding to the GR effect <code>effect</code> for the input group <code>group</code> (if is a String) from all the filenames stored in the Vector <code>names</code>,  and save them in a file named <code>out</code>.</p><p>The first column of <code>out</code> will be the same as the first column of the first filename in <code>names</code>; it is however checked internally if the first column of all the other files coincides with this one. The following columns of <code>out</code> follow the order in <code>names</code>. Note that <code>effect</code>, if passed as Integer, must be &gt; 1 (because 1 is the index of the first column, used as x-axis).</p><p><code>group</code> must be one among the following: [&quot;LD&quot;, &quot;GNC&quot;, &quot;GNCxLD&quot;, &quot;LDxGNC&quot;, &quot;generic&quot;] If <code>group=generic</code>, then <code>effect</code> must be an integer (because  you are not selecting a specific effect in one of the native GaPSE groups).</p><p><code>xdt</code> and <code>ydt</code> are the data types to be used for respectively the first column and the 2-3-4-... columns  of <code>out</code>. Set <code>comments=true</code> if the files in <code>names</code> start with a header that must be skipped (its lines must start with #, otherwise they will not be recognised as comments).</p><p><strong>Example</strong></p><p>julia&gt; run(<code>cat file_1.txt</code>)</p><p><strong>Generic comment line</strong></p><p><strong>of the file_1.txt</strong></p><p>1.0  0.999999  0.34545   0.00991 ...  ...       ...       ...</p><p>julia&gt; run(<code>cat file_2.txt</code>)</p><p><strong>same, for file_2.txt</strong></p><p>1.0  0.58244  0.12123    0.000154 ...  ...       ...       ...</p><p>julia&gt; create<em>file</em>for<em>XiMultipoles(&quot;mix.txt&quot;, [&quot;file</em>1.txt&quot;, &quot;file_2.txt&quot;], 3, &quot;generic&quot;); julia&gt; run(<code>cat mix.txt</code>) ###############</p><p><strong>GaPSE</strong></p><p>############### </p><p><strong></strong></p><p><strong></strong></p><p><strong>This is a table containing the multipoles of the Two-Point Correlation Function (TPCF)</strong></p><p><strong>for a generic group effect [not given, provied only the index 2] taken from the files:</strong></p><p><strong>- L = 0 : file_1.txt</strong></p><p><strong>- L = 1 : file_2.txt</strong></p><p><strong></strong></p><p><strong>s [Mpc/h<em>0]     xi</em>{L=0}      xi_{L=1}</strong></p><p>1.0   0.34545   0.12123  ...   ...       ...</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/foglienimatteo/GaPSE.jl/blob/e601437c432ee08c2009b9fd4aee18390ba3e877/src/PowerSpectraGenWin.jl#L71-L122">source</a></section></article><h2 id="The-Power-Spectrum-for-a-GenWin"><a class="docs-heading-anchor" href="#The-Power-Spectrum-for-a-GenWin">The Power Spectrum for a GenWin</a><a id="The-Power-Spectrum-for-a-GenWin-1"></a><a class="docs-heading-anchor-permalink" href="#The-Power-Spectrum-for-a-GenWin" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GaPSE.GenericWindow" href="#GaPSE.GenericWindow"><code>GaPSE.GenericWindow</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GenericWindow(
    comdist::Vector{Float64}
    multipoles::Vector{Vector{Float64}}
    splines::Vector{Dierckx.Spline1D}
)</code></pre><p>Stores the multipoles of a generic window function, computed as:</p><p class="math-container">\[    Q_{\ell_1} = \int_0^{\infty} \mathrm{d}s_1 \, s_1^2 \, \phi(s_1) \, F_{\ell_1}(s_1,s)\]</p><p>with some FFT algorithm. See Eq. (2.13) of Castorina, Di Dio (2021) for more details.</p><p><strong>Constructors</strong></p><pre><code class="nohighlight hljs">GenericWindow(file::String; comments::Bool=true, xdt::DataType=Float64, ydt::DataType=Float64)</code></pre><p>Read the file <code>file</code> and create a <code>GenericWindow</code> struct having</p><ul><li>as first element the comoving distances stored in the first column (with the input type <code>xdt</code>)</li><li>as second element a vector that contains all the following columns  (with the input type <code>ydt</code>), which are the multipoles <code>L=0,1,2,...</code> of the Window FUnction considered</li><li>as second element a vector that contains all the splines of that multipoles</li></ul><p>If the file start with comments (lines starting with #), set <code>comments = true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/foglienimatteo/GaPSE.jl/blob/e601437c432ee08c2009b9fd4aee18390ba3e877/src/PowerSpectraGenWin.jl#L21-L46">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GaPSE.PS_multipole_GenWin" href="#GaPSE.PS_multipole_GenWin"><code>GaPSE.PS_multipole_GenWin</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">PS_multipole_GenWin(
    ximult::Union{XiMultipoles,String}, genwin::Union{GenericWindow,String};
    alg::Symbol=:fftlog, L::Int=0,
    cut_first_n::Int=0, cut_last_n::Int=0,
    kwargs...)</code></pre><p>Return the <code>L</code>-order Power Spectrum (PS) multipole for a generic window function, through the following Fast Fourier Transform and the effective redshift approximation:</p><p class="math-container">\[    \left\langle \hat{P}_L(k) \right\rangle = 
        \frac{2 L + 1}{A} (-i)^L
        \sum_{\ell=0}^{\infty} 
        \sum_{\ell_1=0}^{\infty} 
        \begin{pmatrix}
            L &amp; \ell &amp; \ell_1 \\
            0 &amp; 0 &amp; 0
        \end{pmatrix}^2
        \int_0^{\infty}\!\mathrm{d} s \, s^2 \, \xi_\ell(s, s_{\rm eff}) \, 
        j_L(k s) \, Q_{\ell_1}(s) \, ,\]</p><p>where:</p><ul><li><span>$\left\langle \hat{P}_L(k) \right\rangle$</span> is the order <span>$L$</span> Power Spectrum of the effect we  are interested in; we are basing this expression on the Yamamoto estimator (see Yamamoto (2000) and  Yamamoto (2006))</li><li><span>$A$</span> is a normalization constant</li><li>the 2x3 matrix represents the Wigner-3j symbols</li><li><span>$\xi_\ell$</span> is the order <span>$\ell$</span> multipole of the Two-Point Correlation Function (TPCF)</li><li><span>$j_L$</span> is the spherical Bessel function of order <span>$L$</span></li><li><span>$s_{\mathrm{eff}}$</span> is the comoving distance associated with the effective redshift (see the  <code>TUTORIAL.ipynb</code> notebook)</li></ul><p><span>$Q_{\ell_1}$</span> can be easily estimated with FFT methods:</p><p class="math-container">\[\begin{split}
    Q_{\ell_1}(s) &amp;:= \int_0^{\infty}\mathrm{d}s_1 \; s_1^2 \;
    \phi(s_1) \; F_{\ell_1}(s_1, s) \\
    F_{\ell_1} (s_1 , s) &amp;:= 
    \int_{4\pi} \mathrm{d}\Omega_{\mathbf{\hat{s}}} \,  
    \int_{4\pi} \mathrm{d}\Omega_{\mathbf{\hat{s}}_1} \,
    \phi(s_2) \, W(\mathbf{\hat{s}}_1) \, W(\mathbf{\hat{s}}_2) \,
    \mathcal{L}_{\ell_1}(\mathbf{\hat{s}} \cdot \mathbf{\hat{s}}_1)  \, .
\end{split}\]</p><p>where:</p><ul><li><span>$\mathcal{L}_{\ell_1}$</span> is the Legendre polynomial of order <span>$\ell_1$</span></li><li><span>$\mathrm{d}\Omega_{\mathbf{\hat{s}}}$</span> is the infinitesimal solid angle pointing in the  direction of the versor <span>$\mathbf{\hat{s}}$</span></li><li><span>$\phi(s)$</span> and  <span>$W(\mathbf{\hat{s}})$</span> are respectively the radial and angular part of your  window function (we remember that we assumed that such separability of the window function is possible)</li></ul><p>Check Eq.(2.13) of Castorina, Di Dio for the theoretical explanation of this formula.</p><p>Currenlty, there are two algorithms you can choose in order to perform the computation; you can choose  which one to use through the keyword value <code>alg</code>:</p><ul><li><code>alg = :fftlog</code> (default and recommended option) will employ the <a href="https://github.com/marcobonici/FFTLog.jl">FFTLog</a>  algorithm.</li><li><code>alg = :twofast</code> will employ the TwoFAST <code>xicalc</code> function of the <a href="https://github.com/hsgg/TwoFAST.jl">TwoFAST</a>  Julia package. Note that in the computation the integration range <span>$0\leq s \leq \infty$</span>  is reduced to <code>int_s_min ‚â§ s ‚â§ int_s_max</code>. This alogrithm is not the ideal choise, because TwoFAST is conceived for the direction PS -&gt; TPCF, while is not 100% trustworthy for the other way round.</li></ul><p>IMPORTANT: no matter which algorithm you choose, you will need to give the input data in a LOGARITHMICALLY DISTRIBUTED scale. A linear distribution does not fit for the algorithms to apply.</p><p><strong>Inputs</strong></p><ul><li><p><code>ximult::Union{XiMultipoles,String}</code> : Two-Point Correlation functions to be used in the computation. You can provide either a <code>XiMultipoles</code> struct containing them or the String filename where they are stored (that will  be internally open with <code>XiMultipoles</code> too).  The file must have a structure analogous to the <code>genwin</code> one (see the next Inputs item). You can use  <code>create_file_for_XiMultipoles</code> to produce such a file.</p></li><li><p><code>genwin::Union{GenericWindow,String}</code> : multipoles <span>$Q_{\ell_1}$</span> of the generic window function you want  to consider. You can provide either a <code>GenericWindow</code> struct containing them or the String filename  where they are stored (that will be internally open with <code>GenericWindow</code> too).  The file must have the following structure</p><pre><code class="language-text hljs">  $ cat Ql_multipoles.txt 
  # Any comment line in the file must start with a #
  # you can have how many comment lines you want in the header; they 
  # will be all skipped.
  # Then you must provide in blank space separated columns:
  # - as first column, the comoving distance values, measured in Mpc/h_0
  # - from the second column onwards, all the Q_{ll_1} multipoles you want;
  #   they must be ordered followinf the ascending multipole order (so ll_1 = 0
  #   must be the 2 column), and you can go as further as you want in the multipole
  #   order
  # 
  # s [Mpc/h_0]      Q_{l1=0}      Q_{l1=1}      Q_{l1=2}      ...
  1.0     0.9999999999999999      1.445269850978461e-7      0.000011917268941324522    ...
  21.0    0.9832914433168294      -0.0025537781362117177  -0.0033199998619560947        ...
  41.0    0.9669175943095181      -0.004923364937797496      -0.006463561496567318        ...     
  ...     ...                  ...                      ...</code></pre></li></ul><p><strong>Optional arguments</strong></p><p>Depending on the algorithm you choose, the options would change. The options in common are:</p><ul><li><code>pr::Bool=true</code> : want to print the automatic messages to the screen?</li><li><code>L::Int=0</code> : which multipole order should I use for this computation? IT MUST MATCH  THE MULTIPOLE ORDER OF THE INPUT TPCF!</li><li><code>cut_first_n::Int=0</code> and <code>cut_last_n::Int=0</code> : you can cout the first and/or last n elements of the input data, if they are highly irregular.</li></ul><p>The specific ones for <code>alg = :fftlog</code> are:</p><ul><li><code>ŒΩ::Union{Float64,Nothing} = nothing</code> : bias parameter, i.e. exponent used to &quot;balance&quot; the curve; if <code>nothing</code>, will be set automatically to <code>1.5</code></li><li><code>n_extrap_low::Int = 500</code> and <code>n_extrap_high::Int = 500</code> : number of points to concatenate on the left/right of the input x-axis <code>ss</code> vector, logarithmically distributed with the same ratio of the left/right-edge elements of <code>ss</code>.</li><li><code>n_pad::Int = 500</code> : number of zeros to be concatenated both on the left and on the right of the input function. They stabilize a lot the algorithm.</li></ul><p>The specific ones for <code>alg = :twofast</code> are:</p><ul><li><code>epl::Bool=true</code> : do you want to extend the edges of the input vectors using two fitted power-laws (obtained from <code>EPLs</code>)</li><li><code>N_left::Int = 12</code> and <code>N_right::Int = 12</code> : number of points from left right edges to be used for the power law fitting in <code>EPLs</code>. They matters only if in the given input file Œæ is not defined until the extremes of integration <code>int_s_min</code> and <code>int_s_max</code>.</li><li><code>int_s_min::Float64 = 1e-1</code> and <code>int_s_max::Float64 = 1e3</code>: extremes of integration; if <code>epl</code> is set to <code>false</code>, their values will be automatically set to <code>min(ss...)</code> and <code>max(ss...)</code> respectively. Their values do matter only if <code>epl=true</code>. </li><li><code>p0_left=[-2.0, 1.0]</code> and <code>p0_right=[-2.0, 1.0]</code>: vectors with the initial values for the left/right  power-law fitting of <code>EPLs</code>; the power-law is in the form <span>$y = f(x) = b * x^s$</span>, so the first vector  value is the initial value of <span>$s$</span> (and of course the second is the one of <span>$b$</span>).</li><li><code>k0::Union{Nothing,Float64} = nothing</code> : starting point for the <code>xicalc</code> function; if <code>nothing</code>,  it will be set <code>k0 = 1.0 / max(ss...)</code></li><li><code>right::Union{Float64,Nothing} = nothing</code> : do you want to cut the output elements with  <code>ks .&gt; right</code>? if set to <code>nothing</code>, no cut will be done.</li><li><code>N::Int = 1024</code> : number of points to be used in Fourier transform </li></ul><p><strong>Returns</strong></p><p>A <code>Tuple{Vector{Float64}, Vector{Float64}}</code> with:</p><ul><li>the <code>k</code> values vector as first element;</li><li>the correspoding PS <code>pk</code> values vector as second one.</li></ul><p>See also: <a href="#GaPSE.create_file_for_XiMultipoles"><code>create_file_for_XiMultipoles</code></a>, <a href="#GaPSE.XiMultipoles"><code>XiMultipoles</code></a>,  <a href="#GaPSE.GenericWindow"><code>GenericWindow</code></a>, <a href="../CosmoUtils/#GaPSE.V_survey"><code>V_survey</code></a>, <a href="../CosmoUtils/#GaPSE.A"><code>A</code></a>, <a href="../CosmoUtils/#GaPSE.A_prime"><code>A_prime</code></a>, <a href="../MathUtils/#GaPSE.EPLs"><code>EPLs</code></a>,  <a href="../PowerSpectra/#GaPSE.print_PS_multipole"><code>print_PS_multipole</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/foglienimatteo/GaPSE.jl/blob/e601437c432ee08c2009b9fd4aee18390ba3e877/src/PowerSpectraGenWin.jl#L280-L430">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GaPSE.print_PS_multipole_GenWin" href="#GaPSE.print_PS_multipole_GenWin"><code>GaPSE.print_PS_multipole_GenWin</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">print_PS_multipole_GenWin(
    ximult::Union{XiMultipoles,String}, genwin::Union{GenericWindow,String},
    out::String; alg::Symbol=:fftlog, L::Int=0, 
    cut_first_n::Int=0, cut_last_n::Int=0,
    kwargs...)</code></pre><p>Compute and save in the file <code>out</code>  the <code>L</code>-order Power Spectrum (PS) multipole for a generic window function, through the following Fast Fourier Transform and the effective redshift approximation:</p><p class="math-container">\[    \left\langle \hat{P}_L(k) \right\rangle = 
        \frac{2 L + 1}{A} (-i)^L
        \sum_{\ell=0}^{\infty} 
        \sum_{\ell_1=0}^{\infty} 
        \begin{pmatrix}
            L &amp; \ell &amp; \ell_1 \\
            0 &amp; 0 &amp; 0
        \end{pmatrix}^2
        \int_0^{\infty}\!\mathrm{d} s \, s^2 \, \xi_\ell(s, s_{\rm eff}) \, 
        j_L(k s) \, Q_{\ell_1}(s) \, ,\]</p><p>where:</p><ul><li><span>$\left\langle \hat{P}_L(k) \right\rangle$</span> is the order <span>$L$</span> Power Spectrum of the effect we  are interested in; we are basing this expression on the Yamamoto estimator (see Yamamoto (2000) and  Yamamoto (2006))</li><li><span>$A$</span> is a normalization constant</li><li>the 2x3 matrix represents the Wigner-3j symbols</li><li><span>$\xi_\ell$</span> is the order <span>$\ell$</span> multipole of the Two-Point Correlation Function (TPCF)</li><li><span>$j_L$</span> is the spherical Bessel function of order <span>$L$</span></li><li><span>$s_{\mathrm{eff}}$</span> is the comoving distance associated with the effective redshift (see the  <code>TUTORIAL.ipynb</code> notebook)</li></ul><p><span>$Q_{\ell_1}$</span> can be easily estimated with FFT methods:</p><p class="math-container">\[\begin{split}
    Q_{\ell_1}(s) &amp;:= \int_0^{\infty}\mathrm{d}s_1 \; s_1^2 \;
    \phi(s_1) \; F_{\ell_1}(s_1, s) \\
    F_{\ell_1} (s_1 , s) &amp;:= 
    \int_{4\pi} \mathrm{d}\Omega_{\mathbf{\hat{s}}} \,  
    \int_{4\pi} \mathrm{d}\Omega_{\mathbf{\hat{s}}_1} \,
    \phi(s_2) \, W(\mathbf{\hat{s}}_1) \, W(\mathbf{\hat{s}}_2) \,
    \mathcal{L}_{\ell_1}(\mathbf{\hat{s}} \cdot \mathbf{\hat{s}}_1)  \, .
\end{split}\]</p><p>where:</p><ul><li><span>$\mathcal{L}_{\ell_1}$</span> is the Legendre polynomial of order <span>$\ell_1$</span></li><li><span>$\mathrm{d}\Omega_{\mathbf{\hat{s}}}$</span> is the infinitesimal solid angle pointing in the  direction of the versor <span>$\mathbf{\hat{s}}$</span></li><li><span>$\phi(s)$</span> and  <span>$W(\mathbf{\hat{s}})$</span> are respectively the radial and angular part of your  window function (we remember that we assumed that such separability of the window function is possible)</li></ul><p>Check Eq.(2.13) of Castorina, Di Dio for the theoretical explanation of this formula.</p><p>Currenlty, there are two algorithms you can choose in order to perform the computation; you can choose  which one to use through the keyword value <code>alg</code>:</p><ul><li><code>alg = :fftlog</code> (default and recommended option) will employ the <a href="https://github.com/marcobonici/FFTLog.jl">FFTLog</a>  algorithm.</li><li><code>alg = :twofast</code> will employ the TwoFAST <code>xicalc</code> function of the <a href="https://github.com/hsgg/TwoFAST.jl">TwoFAST</a>  Julia package. Note that in the computation the integration range <span>$0\leq s \leq \infty$</span>  is reduced to <code>int_s_min ‚â§ s ‚â§ int_s_max</code>. This alogrithm is not the ideal choise, because TwoFAST is conceived for the direction PS -&gt; TPCF, while is not 100% trustworthy for the other way round.</li></ul><p>IMPORTANT: no matter which algorithm you choose, you will need to give the input data in a LOGARITHMICALLY DISTRIBUTED scale. A linear distribution does not fit for the algorithms to apply.</p><p><strong>Inputs</strong></p><ul><li><p><code>ximult::Union{XiMultipoles,String}</code> : Two-Point Correlation functions to be used in the computation. You can provide either a <code>XiMultipoles</code> struct containing them or the String filename where they are stored (that will  be internally open with <code>XiMultipoles</code> too).  The file must have a structure analogous to the <code>genwin</code> one (see the next Inputs item). You can use  <code>create_file_for_XiMultipoles</code> to produce such a file.</p></li><li><p><code>genwin::Union{GenericWindow,String}</code> : multipoles <span>$Q_{\ell_1}$</span> of the generic window function you want  to consider. You can provide either a <code>GenericWindow</code> struct containing them or the String filename  where they are stored (that will be internally open with <code>GenericWindow</code> too).  The file must have the following structure</p><pre><code class="language-text hljs">  $ cat Ql_multipoles.txt 
  # Any comment line in the file must start with a #
  # you can have how many comment lines you want in the header; they 
  # will be all skipped.
  # Then you must provide in blank space separated columns:
  # - as first column, the comoving distance values, measured in Mpc/h_0
  # - from the second column onwards, all the Q_{ll_1} multipoles you want;
  #   they must be ordered followinf the ascending multipole order (so ll_1 = 0
  #   must be the 2 column), and you can go as further as you want in the multipole
  #   order
  # 
  # s [Mpc/h_0]      Q_{l1=0}      Q_{l1=1}      Q_{l1=2}      ...
  1.0     0.9999999999999999      1.445269850978461e-7      0.000011917268941324522    ...
  21.0    0.9832914433168294      -0.0025537781362117177  -0.0033199998619560947        ...
  41.0    0.9669175943095181      -0.004923364937797496      -0.006463561496567318        ...     
  ...     ...                  ...                      ...</code></pre></li><li><p><code>out::String</code> : name of the file where the results must be stored.</p></li></ul><p><strong>Optional arguments</strong></p><p>Depending on the algorithm you choose, the options would change. The options in common are:</p><ul><li><code>pr::Bool=true</code> : want to print the automatic messages to the screen?</li><li><code>L::Int=0</code> : which multipole order should I use for this computation? IT MUST MATCH  THE MULTIPOLE ORDER OF THE INPUT TPCF!</li><li><code>cut_first_n::Int=0</code> and <code>cut_last_n::Int=0</code> : you can cout the first and/or last n elements of the input data, if they are highly irregular.</li></ul><p>The specific ones for <code>alg = :fftlog</code> are:</p><ul><li><code>ŒΩ::Union{Float64,Nothing} = nothing</code> : bias parameter, i.e. exponent used to &quot;balance&quot; the curve; if <code>nothing</code>, will be set automatically to <code>1.5</code></li><li><code>n_extrap_low::Int = 500</code> and <code>n_extrap_high::Int = 500</code> : number of points to concatenate on the left/right of the input x-axis <code>ss</code> vector, logarithmically distributed with the same ratio of the left/right-edge elements of <code>ss</code>.</li><li><code>n_pad::Int = 500</code> : number of zeros to be concatenated both on the left and on the right of the input function. They stabilize a lot the algorithm.</li></ul><p>The specific ones for <code>alg = :twofast</code> are:</p><ul><li><code>epl::Bool=true</code> : do you want to extend the edges of the input vectors using two fitted power-laws (obtained from <code>EPLs</code>)</li><li><code>N_left::Int = 12</code> and <code>N_right::Int = 12</code> : number of points from left right edges to be used for the power law fitting in <code>EPLs</code>. They matters only if in the given input file Œæ is not defined until the extremes of integration <code>int_s_min</code> and <code>int_s_max</code>.</li><li><code>int_s_min::Float64 = 1e-1</code> and <code>int_s_max::Float64 = 1e3</code>: extremes of integration; if <code>epl</code> is set to <code>false</code>, their values will be automatically set to <code>min(ss...)</code> and <code>max(ss...)</code> respectively. Their values do matter only if <code>epl=true</code>. </li><li><code>p0_left=[-2.0, 1.0]</code> and <code>p0_right=[-2.0, 1.0]</code>: vectors with the initial values for the left/right  power-law fitting of <code>EPLs</code>; the power-law is in the form <span>$y = f(x) = b * x^s$</span>, so the first vector  value is the initial value of <span>$s$</span> (and of course the second is the one of <span>$b$</span>).</li><li><code>k0::Union{Nothing,Float64} = nothing</code> : starting point for the <code>xicalc</code> function; if <code>nothing</code>,  it will be set <code>k0 = 1.0 / max(ss...)</code></li><li><code>right::Union{Float64,Nothing} = nothing</code> : do you want to cut the output elements with  <code>ks .&gt; right</code>? if set to <code>nothing</code>, no cut will be done.</li><li><code>N::Int = 1024</code> : number of points to be used in Fourier transform </li></ul><p>See also: <a href="#GaPSE.create_file_for_XiMultipoles"><code>create_file_for_XiMultipoles</code></a>, <a href="#GaPSE.XiMultipoles"><code>XiMultipoles</code></a>,  <a href="#GaPSE.GenericWindow"><code>GenericWindow</code></a>, <a href="../CosmoUtils/#GaPSE.V_survey"><code>V_survey</code></a>, <a href="../CosmoUtils/#GaPSE.A"><code>A</code></a>, <a href="../CosmoUtils/#GaPSE.A_prime"><code>A_prime</code></a>, <a href="../MathUtils/#GaPSE.EPLs"><code>EPLs</code></a>,  <a href="../PowerSpectra/#GaPSE.print_PS_multipole"><code>print_PS_multipole</code></a>, <a href="#GaPSE.PS_multipole_GenWin"><code>PS_multipole_GenWin</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/foglienimatteo/GaPSE.jl/blob/e601437c432ee08c2009b9fd4aee18390ba3e877/src/PowerSpectraGenWin.jl#L544-L690">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../PowerSpectra/">¬´ Calculating Power Spectra</a><a class="docs-footer-nextpage" href="../PNG/">implication on PNG ¬ª</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.2.1 on <span class="colophon-date" title="Friday 23 February 2024 12:23">Friday 23 February 2024</span>. Using Julia version 1.9.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
